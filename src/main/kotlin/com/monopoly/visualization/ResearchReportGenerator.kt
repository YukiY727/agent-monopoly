package com.monopoly.visualization

import com.monopoly.statistics.BoardStatistics
import com.monopoly.statistics.DetailedStatistics
import java.io.File
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

/**
 * 研究論文用レポートを生成
 */
class ResearchReportGenerator(
    private val heatmapGenerator: HeatmapGenerator = HeatmapGenerator(),
    private val radarChartGenerator: RadarChartGenerator = RadarChartGenerator(),
    private val scatterPlotGenerator: ScatterPlotGenerator = ScatterPlotGenerator(),
    private val barChartGenerator: BarChartGenerator = BarChartGenerator(),
    private val lineChartGenerator: LineChartGenerator = LineChartGenerator(),
) {
    /**
     * 研究レポートHTMLを生成
     */
    fun generate(
        detailedStats: DetailedStatistics,
        boardStats: BoardStatistics
    ): String {
        return buildString {
            appendLine("<!DOCTYPE html>")
            appendLine("<html lang=\"en\">")
            appendLine("<head>")
            appendLine(generateHead())
            appendLine("</head>")
            appendLine("<body>")
            appendLine("  <div class=\"container\">")

            appendLine(generateTitle())
            appendLine(generateAbstract(detailedStats))
            appendLine(generateMethodology(detailedStats))
            appendLine(generateResults(detailedStats, boardStats))
            appendLine(generateDiscussion())
            appendLine(generateConclusion())
            appendLine(generateReferences())

            appendLine("  </div>")
            appendLine("</body>")
            appendLine("</html>")
        }
    }

    /**
     * ファイルに保存
     */
    fun saveToFile(
        detailedStats: DetailedStatistics,
        boardStats: BoardStatistics,
        filename: String = generateFilename()
    ): File {
        val file = File(filename)
        file.writeText(generate(detailedStats, boardStats))
        return file
    }

    private fun generateHead(): String {
        return """
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Monopoly Strategy Analysis - Research Report</title>
        <style>
        ${generateStyles()}
        </style>
        """.trimIndent()
    }

    private fun generateStyles(): String {
        return """
        body {
            font-family: 'Times New Roman', serif;
            background: #f5f5f5;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 60px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            font-size: 24pt;
            margin-bottom: 10px;
        }
        .authors {
            text-align: center;
            font-style: italic;
            margin-bottom: 30px;
        }
        .section {
            margin: 40px 0;
        }
        .section h2 {
            font-size: 18pt;
            border-bottom: 2px solid #333;
            padding-bottom: 5px;
            margin-top: 30px;
        }
        .section h3 {
            font-size: 14pt;
            margin-top: 20px;
        }
        .abstract {
            background: #f9f9f9;
            padding: 20px;
            border-left: 4px solid #333;
            margin: 30px 0;
        }
        .chart-container {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #fafafa;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 11pt;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border: 1px solid #ddd;
        }
        th {
            background-color: #f0f0f0;
            font-weight: bold;
        }
        .number {
            text-align: right;
        }
        """.trimIndent()
    }

    private fun generateTitle(): String {
        return """
        <h1>Strategic Decision-Making in Monopoly:<br>A Computational Analysis</h1>
        <div class="authors">
            Generated by Monopoly Simulator v1.0
        </div>
        """.trimIndent()
    }

    private fun generateAbstract(detailedStats: DetailedStatistics): String {
        val totalGames = detailedStats.basicStats.totalGames
        val numStrategies = detailedStats.basicStats.playerStats.size

        return """
        <div class="abstract">
            <h2>Abstract</h2>
            <p>
            This study presents a computational analysis of strategic decision-making in the board game Monopoly.
            We simulated $totalGames games with $numStrategies different strategies to evaluate their effectiveness
            under various conditions. Our results provide insights into optimal property acquisition strategies,
            resource management, and risk assessment in competitive scenarios.
            </p>
        </div>
        """.trimIndent()
    }

    private fun generateMethodology(detailedStats: DetailedStatistics): String {
        val strategies = detailedStats.basicStats.playerStats.keys.joinToString(", ")

        return """
        <div class="section">
            <h2>1. Methodology</h2>
            <h3>1.1 Simulation Setup</h3>
            <p>
            We conducted ${detailedStats.basicStats.totalGames} Monte Carlo simulations of Monopoly games
            using a custom game engine. Each simulation followed standard Monopoly rules with deterministic
            property prices and rent values.
            </p>
            <h3>1.2 Strategies Evaluated</h3>
            <p>
            The following strategies were tested: $strategies.
            Each strategy represents a different approach to property acquisition and resource management.
            </p>
            <h3>1.3 Metrics</h3>
            <p>
            We measured win rate, average final assets, property ownership patterns, and bankruptcy rates
            for each strategy across all simulations.
            </p>
        </div>
        """.trimIndent()
    }

    private fun generateResults(
        detailedStats: DetailedStatistics,
        boardStats: BoardStatistics
    ): String {
        return buildString {
            appendLine("<div class=\"section\">")
            appendLine("  <h2>2. Results</h2>")

            // 2.1 Overview
            appendLine(generateResultsOverview(detailedStats))

            // 2.2 Strategy Comparison
            appendLine(generateStrategyComparison(detailedStats))

            // 2.3 Property Analysis
            appendLine(generatePropertyAnalysis(detailedStats, boardStats))

            // 2.4 Asset Progression
            appendLine(generateAssetProgression(detailedStats))

            appendLine("</div>")
        }
    }

    private fun generateResultsOverview(detailedStats: DetailedStatistics): String {
        return """
        <h3>2.1 Overview</h3>
        <p>
        Average game length: ${String.format("%.1f", detailedStats.basicStats.turnStats.averageTurns)} turns.
        Range: ${detailedStats.basicStats.turnStats.minTurns}-${detailedStats.basicStats.turnStats.maxTurns} turns.
        </p>
        """.trimIndent()
    }

    private fun generateStrategyComparison(detailedStats: DetailedStatistics): String {
        // レーダーチャート
        val colors = listOf("#3498db", "#e74c3c", "#2ecc71", "#f39c12", "#9b59b6", "#1abc9c")
        val radarData = RadarChartData(
            title = "Strategy Comparison",
            axes = listOf(
                RadarChartData.Axis("Win Rate"),
                RadarChartData.Axis("Avg Assets"),
                RadarChartData.Axis("Properties"),
                RadarChartData.Axis("Survival"),
                RadarChartData.Axis("Efficiency")
            ),
            series = detailedStats.basicStats.playerStats.values.mapIndexed { index, playerStats ->
                val bankruptcyCount = detailedStats.bankruptcyAnalysis.getBankruptcyCountByPlayer()[playerStats.playerName] ?: 0
                RadarChartData.Series(
                    label = playerStats.playerName,
                    values = listOf(
                        playerStats.winRate,
                        playerStats.averageFinalAssets / 5000.0, // 正規化
                        playerStats.averagePropertiesOwned / 28.0, // 最大28プロパティ
                        1.0 - bankruptcyCount.toDouble() / detailedStats.basicStats.totalGames,
                        1.0 / (detailedStats.basicStats.turnStats.averageTurns / 100.0) // 効率性
                    ),
                    color = colors[index % colors.size]
                )
            }
        )

        // 散布図
        val scatterData = ScatterPlotData(
            title = "Win Rate vs Average Final Assets",
            xAxisLabel = "Win Rate",
            yAxisLabel = "Average Final Assets ($)",
            points = detailedStats.basicStats.playerStats.values.mapIndexed { index, playerStats ->
                ScatterPlotData.Point(
                    label = playerStats.playerName,
                    x = playerStats.winRate,
                    y = playerStats.averageFinalAssets,
                    color = colors[index % colors.size]
                )
            }
        )

        return buildString {
            appendLine("<h3>2.2 Strategy Comparison</h3>")
            appendLine("<div class=\"chart-container\">")
            appendLine(radarChartGenerator.generate(radarData))
            appendLine("</div>")
            appendLine("<div class=\"chart-container\">")
            appendLine(scatterPlotGenerator.generate(scatterData))
            appendLine("</div>")
        }
    }

    private fun generatePropertyAnalysis(
        detailedStats: DetailedStatistics,
        boardStats: BoardStatistics
    ): String {
        // 停止回数ヒートマップ
        val landedHeatmap = HeatmapData(
            title = "Landing Frequency Heatmap",
            cells = boardStats.positionStats.values.map { stats ->
                HeatmapData.Cell(
                    label = stats.position.toString(),
                    value = stats.landedCount.toDouble(),
                    position = stats.position
                )
            }
        )

        // 収益性ヒートマップ
        val profitabilityHeatmap = HeatmapData(
            title = "Profitability Heatmap",
            cells = boardStats.positionStats.values.map { stats ->
                HeatmapData.Cell(
                    label = stats.position.toString(),
                    value = stats.totalRentCollected,
                    position = stats.position
                )
            }
        )

        return buildString {
            appendLine("<h3>2.3 Property Analysis</h3>")
            appendLine("<p>Board position heatmaps showing landing frequency and profitability.</p>")
            appendLine("<div class=\"chart-container\">")
            appendLine(heatmapGenerator.generate(landedHeatmap))
            appendLine("</div>")
            appendLine("<div class=\"chart-container\">")
            appendLine(heatmapGenerator.generate(profitabilityHeatmap))
            appendLine("</div>")
        }
    }

    private fun generateAssetProgression(detailedStats: DetailedStatistics): String {
        val colors = listOf("#3498db", "#e74c3c", "#2ecc71", "#f39c12", "#9b59b6", "#1abc9c")
        val playerNames = detailedStats.basicStats.playerStats.keys.toList()

        val lineChartData = LineChartData(
            title = "Average Asset Progression",
            lines = playerNames.mapIndexed { index, playerName ->
                LineChartData.Line(
                    label = playerName,
                    points = detailedStats.assetHistory.getAverageAssetsByPlayer(playerName),
                    color = colors[index % colors.size]
                )
            }
        )

        return buildString {
            appendLine("<h3>2.4 Asset Progression</h3>")
            appendLine("<div class=\"chart-container\">")
            appendLine(lineChartGenerator.generate(lineChartData))
            appendLine("</div>")
        }
    }

    private fun generateDiscussion(): String {
        return """
        <div class="section">
            <h2>3. Discussion</h2>
            <p>
            [Discussion section to be filled with analysis of the results.]
            </p>
        </div>
        """.trimIndent()
    }

    private fun generateConclusion(): String {
        return """
        <div class="section">
            <h2>4. Conclusion</h2>
            <p>
            [Conclusion section summarizing key findings.]
            </p>
        </div>
        """.trimIndent()
    }

    private fun generateReferences(): String {
        return """
        <div class="section">
            <h2>References</h2>
            <p>
            [1] Reference 1<br>
            [2] Reference 2
            </p>
        </div>
        """.trimIndent()
    }

    private fun generateFilename(): String {
        val formatter = DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss")
        val timestamp = LocalDateTime.now().format(formatter)
        return "monopoly-research-report-$timestamp.html"
    }
}
