# 開発計画

## 開発アプローチ

このプロジェクトは**曳光弾開発（Tracer Bullet Development）** のアプローチを採用します。

### 曳光弾開発を選択する理由

1. **不確実性の高さ**: モノポリーシミュレーション研究という新領域で、実装してみないと分からない要素が多い
2. **早期フィードバック**: 動くものを早期に作り、データ構造や戦略インターフェースの妥当性を検証
3. **段階的な複雑度管理**: シンプルな実装から始め、学習しながら機能を追加
4. **リスク軽減**: 各フェーズで動作するソフトウェアを保持し、後戻りコストを最小化

### 各フェーズでのVモデル適用

各フェーズでは以下のVモデルのサイクルを実施します：

```
詳細仕様 → 設計 → 実装 → テスト
   ↓                        ↑
   └────────────────────────┘
        検証・フィードバック
```

#### 各工程の内容

1. **詳細仕様**: そのフェーズで実装する機能の詳細を定義
2. **設計**: データ構造、モジュール分割、インターフェースを設計
3. **実装**: 設計に基づいてコードを記述
4. **テスト**: ユニットテスト・統合テストで検証し、仕様を満たしているか確認

各フェーズ完了時には、次フェーズに進む前に必ず動作するソフトウェアを保持します。

## 開発フェーズ

### Phase 1: 最小限のゲーム実行

**目標**: 1ゲームを最後まで実行し、勝者を表示できる

#### 開発ステップ

1. **詳細仕様**: 最小限のゲームルール、基本データ構造の仕様化
2. **設計**: コアデータ構造、ゲームループの設計
3. **実装**: 基本ゲームエンジンと1つのシンプルな戦略
4. **テスト**: ゲームが最後まで実行できることを確認

#### 実装範囲
- **最小限のデータ構造**
  - ボード（マス目の基本定義）
  - プレイヤー（所持金、位置）
  - プロパティ（価格、所有者）

- **基本ゲームロジック**
  - サイコロ振り
  - マスの移動
  - 土地の購入判定（常に購入する戦略のみ）
  - 破産判定
  - ゲーム終了条件

- **CLI出力**
  - 勝者の表示のみ

#### 成果物
- 最小限のゲームエンジン
- 1つのシンプルな戦略（常に購入）
- **UI成果物**: CLIで実行して勝者を表示（ターミナル出力）
- 基本的なユニットテスト

#### 検証項目
- ゲームが最後まで実行されるか
- 勝者が正しく判定されるか

---

### Phase 2: イベント記録システム

**目標**: ゲーム進行を最初から最後まで追跡できるようにする（最小限の実装）

#### 開発ステップ

1. **詳細仕様**: イベント型の定義、記録する情報の定義
2. **設計**: イベントログ記録の仕組み、JSON保存の設計
3. **実装**: イベント記録とJSON保存機能
4. **テスト**: イベントログが正しく記録されることを確認

#### 実装範囲
- **イベント記録機能**
  - GameEventのsealed class定義
  - GameStateへのイベントログ追加
  - GameServiceでのイベント記録
  - ターンごとの状態記録
  - 重要なイベント（購入、破産など）の記録

- **JSON保存機能**
  - EventLogger（JSON形式での保存/読み込み）
  - ゲーム終了後のイベントログ保存

#### 成果物
- イベント記録システム
- EventLogger（JSON保存/読み込み）
- **UI成果物**:
  - JSON形式のイベントログファイル出力

#### 検証項目
- ゲームの進行が最初から最後まで記録されているか
- JSONファイルが正しいフォーマットで保存されるか

#### 将来の拡張（Phase 4以降）
- HTMLレポート生成（より完全なルールが実装されてから）
- CLI視覚化（建物システム実装後）

---

### Phase 3: 建物システムとダブル（ゾロ目）

**目標**: 建物建設とゾロ目ルールを実装し、ゲームの戦略性を向上

#### 開発ステップ

1. **詳細仕様**: 建物システムの仕様、ゾロ目ルールの定義
2. **設計**: 建物管理の設計、ターン制御の拡張設計
3. **実装**: 建物建設ロジック、ゾロ目判定と追加ターン
4. **テスト**: 建物システムとゾロ目が正しく動作することを確認

#### 実装範囲

- **建物システム**
  - 家（最大4件）とホテル（1件）の概念
  - Propertyクラスの拡張（家・ホテル数の管理）
  - 同色プロパティ全所有（モノポリー）の判定
  - 建物の均等建設ルール（同色グループ内で差は1件まで）
  - 家賃計算の拡張（建物数に応じた変動）
  - 建物建設イベントの記録

- **ダブル（ゾロ目）**
  - Diceクラスの拡張（個別のサイコロ値を返す）
  - ゾロ目判定ロジック
  - 追加ターン実行
  - 3回連続ゾロ目で刑務所送り（刑務所実装はPhase 4）
  - ゾロ目イベントの記録

#### 成果物

- 建物建設システム
- ゾロ目ルール実装
- **UI成果物**: JSON形式のイベントログに建物イベントとゾロ目情報を追加

#### 検証項目

- 建物が均等に建設されるか
- 家賃が建物数に応じて正しく計算されるか
- ゾロ目で追加ターンが実行されるか
- 3回連続ゾロ目の判定が正しいか

#### 期待される効果

- 戦略の多様性が増す（建設 vs 資金温存）
- ゲーム展開が加速（ゾロ目による追加ターン）
- よりリアルなモノポリー体験

---

### Phase 4: 刑務所とカードシステム

**目標**: 刑務所の収監状態とカード機能を実装し、ゲームのランダム性を追加

#### 開発ステップ

1. **詳細仕様**: 刑務所ルールの仕様、カードシステムの定義
2. **設計**: PlayerStateの拡張、Cardクラスの設計
3. **実装**: 刑務所機能、カードデッキとカード効果
4. **テスト**: 刑務所とカードが正しく動作することを確認

#### 実装範囲

- **刑務所機能**
  - PlayerStateに刑務所状態を追加（収監 vs 訪問）
  - 収監ターン数の追跡
  - 脱出方法の実装:
    - $50支払い
    - ゾロ目を出す（最大3回試行）
    - 脱出カード使用
    - 3ターン経過後の強制脱出
  - 刑務所行きマスの処理
  - 3回連続ゾロ目での刑務所送り

- **カード機能（チャンス・共同基金）**
  - Cardクラスの設計（sealed class）
  - カードデッキの管理
  - カード効果の実装:
    - 移動系（指定マスへ移動、N歩前進/後退）
    - 金銭系（受取/支払い）
    - 特殊系（刑務所行き、脱出カード）
    - 建物課金系（家・ホテルごとの支払い/受取）
  - カードの山札管理（使用後は底へ、脱出カードは保持）
  - カード引きイベントの記録

#### 成果物

- 刑務所システム
- カードシステム（チャンス・共同基金）
- **UI成果物**: JSON形式のイベントログに刑務所とカードイベントを追加

#### 検証項目

- 刑務所の収監と脱出が正しく動作するか
- カード効果が正しく適用されるか
- カードデッキが正しく管理されるか

#### 期待される効果

- ゲームのランダム性が増加
- 戦略の幅が広がる（刑務所での待機戦略など）
- カードによる逆転要素

---

### Phase 5: 税金と特殊プロパティ

**目標**: 税金マスと鉄道・公共施設の特殊な家賃計算を実装

#### 開発ステップ

1. **詳細仕様**: 税金マスの仕様、鉄道・公共施設の家賃計算ルール
2. **設計**: 特殊マス処理の設計、特殊家賃計算ロジックの設計
3. **実装**: 税金マス、鉄道・公共施設の家賃計算
4. **テスト**: 税金と特殊家賃が正しく動作することを確認

#### 実装範囲

- **税金マス**
  - 所得税マス: $200支払い
  - 物品税マス: $100支払い
  - 税金支払い不能時の破産処理
  - 税金イベントの記録

- **鉄道の家賃計算**
  - 所有数に応じた家賃（1件: $25, 2件: $50, 3件: $100, 4件: $200）
  - 同一プレイヤーの鉄道所有数カウント

- **公共施設の家賃計算**
  - サイコロの目 × 所有数倍率（1件: 4倍, 2件: 10倍）
  - 停止時のサイコロ値の再利用

#### 成果物

- 税金マス処理
- 鉄道・公共施設の家賃計算
- **UI成果物**: JSON形式のイベントログに税金イベントを追加

#### 検証項目

- 税金が正しく支払われるか
- 鉄道の家賃が所有数に応じて正しく計算されるか
- 公共施設の家賃がサイコロの目に基づいて正しく計算されるか

#### 期待される効果

- より正確なモノポリールールの再現
- 鉄道・公共施設の戦略的価値が明確に

---

### Phase 6: 抵当システム

**目標**: 抵当機能を実装し、資金調達の選択肢を増やす

#### 開発ステップ

1. **詳細仕様**: 抵当ルールの仕様、利息計算の定義
2. **設計**: PropertyOwnershipの拡張、抵当管理の設計
3. **実装**: 抵当設定・解除、破産処理との統合
4. **テスト**: 抵当システムが正しく動作することを確認

#### 実装範囲

- **抵当設定**
  - PropertyOwnershipに抵当状態を追加
  - 抵当に入れる処理（物件価格の50%獲得）
  - 抵当中は家賃収入なし
  - 建物がある場合は先に売却が必要
  - 抵当イベントの記録

- **抵当解除**
  - 借入額の110%を支払う（10%利息）
  - 所有権の復活

- **破産処理との統合**
  - 抵当物件の譲渡処理
  - 銀行破産時のオークション処理（Phase 7で実装）

#### 成果物

- 抵当システム
- **UI成果物**: JSON形式のイベントログに抵当イベントを追加

#### 検証項目

- 抵当が正しく設定されるか
- 抵当解除時の利息計算が正しいか
- 抵当中の家賃が無効化されるか

#### 期待される効果

- 破産回避の戦略が増える
- 資金繰りの重要性が増す

---

### Phase 7: オークションシステム

**目標**: 購入拒否時のオークションを実装

#### 開発ステップ

1. **詳細仕様**: オークションルールの仕様、入札戦略の定義
2. **設計**: Auctionクラスの設計、入札管理の設計
3. **実装**: オークション機構、入札戦略
4. **テスト**: オークションが正しく動作することを確認

#### 実装範囲

- **オークション機構**
  - Auctionクラスの設計
  - 入札管理（最低$1、所持金上限）
  - パス管理（再参加不可）
  - 落札判定
  - オークションイベントの記録

- **購入拒否時の処理**
  - processUnownedPropertyの拡張
  - 全プレイヤーの入札戦略
  - 戦略インターフェースの拡張（入札判断）

- **破産時のオークション**
  - 銀行破産時の全資産オークション

#### 成果物

- オークションシステム
- **UI成果物**: JSON形式のイベントログにオークションイベントを追加

#### 検証項目

- オークションの入札が正しく管理されるか
- 落札判定が正しいか
- 全プレイヤーパス時の処理が正しいか

#### 期待される効果

- より戦略的な購入判断（高すぎる物件は拒否してオークション狙い）
- プレイヤー間の駆け引き

---

### Phase 8: 複数戦略とゲーム可視化

**目標**: 異なる戦略を実装し、ゲームの進行を視覚的に確認できるようにする

#### 開発ステップ

1. **詳細仕様**: 戦略インターフェースの拡張、CLI視覚化の仕様
2. **設計**: 追加戦略の設計、BoardRendererの設計
3. **実装**: 複数戦略、CLI視覚化
4. **テスト**: 各戦略の動作確認、視覚化の確認

#### 実装範囲

- **追加戦略**
  - ランダム戦略（購入をランダムに決定）
  - 保守的戦略（一定額以上の現金を保持）
  - セット重視戦略（同色セット完成を優先）
  - ROI戦略（投資効率を計算）

- **CLI視覚化（BoardRenderer）**
  - ボードの状態を視覚的に表示
  - 各マス目にプレイヤー位置、所有者、建物数を表示
  - プレイヤー情報（所持金、所有プロパティ）の表示
  - ターンごとの表示更新

- **戦略選択機能**
  - CLIで戦略を指定して実行
  - 複数プレイヤーに異なる戦略を割り当て

#### 成果物

- 複数の戦略実装（4-5種類）
- ボード視覚化システム
- **UI成果物**:
  - CLIでボード状態を視覚的に表示
  - 戦略を指定して実行できるCLI

#### 検証項目

- 各戦略が異なる挙動を示すか
- ボードの視覚化でゲームの状況が理解できるか
- バグが視覚的に発見できるか

#### 期待される効果

- 戦略の比較が可能になる
- 開発中のデバッグが容易になる
- ゲームの状況が一目で把握できる

---

### Phase 9: 複数ゲーム実行と基本統計

**目標**: N回のゲームを実行し、基本的な統計を収集できるようにする

#### 開発ステップ

1. **詳細仕様**: 複数実行の仕様、基本統計項目の定義
2. **設計**: ゲーム実行ループの設計、統計データ構造の設計
3. **実装**: 複数ゲーム実行、統計収集機能
4. **テスト**: 指定回数正しく実行されること、統計が正確に計算されることを確認

#### 実装範囲

- **複数実行機能**
  - N回のゲーム実行
  - 進捗表示（ターミナル）

- **基本統計**
  - 勝率（戦略別）
  - 平均ゲームターン数
  - 平均最終資産額

- **統計出力**
  - JSON/CSV形式での出力

#### 成果物

- N回実行できるCLI
- 統計収集機能
- **UI成果物**:
  - 実行中の進捗表示（ターミナル出力、プログレスバー）
  - 統計ファイル出力（JSON/CSV）
  - CLIで統計サマリー表示

#### 検証項目

- 指定回数実行されるか
- 各ゲームが独立して実行されるか
- 統計データが正確か
- ファイル出力が正しいフォーマットか

---

### Phase 10: HTMLレポートと統計の可視化

**目標**: ゲーム結果とHTMLレポートを生成し、統計結果をグラフで表示できるようにする

#### 開発ステップ

1. **詳細仕様**: HTMLレポートの仕様、グラフの種類、表示項目の定義
2. **設計**: HtmlReportGeneratorの設計、可視化ライブラリの選定
3. **実装**: HTMLレポート生成、グラフ生成機能
4. **テスト**: ブラウザで表示確認、グラフが正しく表示されることを確認

#### 実装範囲

- **HtmlReportGenerator**
  - ゲーム進行の全体表示（最初から最後まで）
  - ターンごとのプレイヤー状態（位置、所持金、所有プロパティ）
  - イベント履歴（サイコロの目、購入/レント支払いなど）
  - シンプルなスタイリング

- **統計グラフ**
  - 勝率の棒グラフ
  - ゲーム長の分布（ヒストグラム）
  - HTMLレポートへの統合

#### 成果物

- HtmlReportGenerator
- グラフ生成機能
- **UI成果物**:
  - ブラウザで開けるゲーム進行HTML（ターンごとの状態とイベント履歴を時系列表示）
  - 戦略別勝率の棒グラフ
  - ゲーム長分布のヒストグラム
  - インタラクティブではない静的グラフ

#### 検証項目

- ブラウザ上でゲームの流れが確認できるか
- グラフが直感的に理解できるか

---

### Phase 11: 並列実行とパフォーマンス最適化

**目標**: シミュレーションを高速化する

#### 開発ステップ

1. **詳細仕様**: 並列実行の仕様、並列度の定義
2. **設計**: 並列処理の設計、スレッド/プロセス管理
3. **実装**: 並列実行機能
4. **テスト**: パフォーマンステスト、正確性の検証

#### 実装範囲

- **並列実行エンジン**
  - マルチスレッド/マルチプロセス対応
  - 結果の集約

#### 成果物

- 並列実行機能
- パフォーマンス向上
- **UI成果物**: 並列実行時の進捗表示（ターミナル、マルチプログレスバー）

#### 検証項目

- パフォーマンスが向上しているか（目安: 10,000ゲーム/分以上）
- 並列実行でも結果が正確か

---

### Phase 12: 詳細統計と高度な分析

**目標**: より詳細な分析項目を追加し、研究レベルのレポートを生成する

#### 開発ステップ

1. **詳細仕様**: 追加統計項目の定義、高度なグラフの仕様
2. **設計**: データ収集の拡張設計、可視化コンポーネントの設計
3. **実装**: 詳細統計収集、高度な可視化機能
4. **テスト**: 統計の正確性検証、レポート品質の確認

#### 実装範囲

- **詳細統計**
  - プロパティ別の収益性
  - ターンごとの資産推移
  - 破産タイミング分析

- **高度なグラフ**
  - 資産推移の折れ線グラフ
  - ヒートマップ（マス目の収益性）
  - 戦略別の詳細比較チャート

- **レポート機能**
  - 研究論文レベルのレポート
  - PDF出力（オプション）

#### 成果物

- 拡張された統計機能
- 高度な可視化機能
- **UI成果物**:
  - プロパティ別収益性ランキング表
  - ターンごとの資産推移グラフ（各プレイヤー）
  - 破産タイミング分布グラフ
  - ボードマス目のヒートマップ（止まった回数、収益性）
  - 戦略間の詳細比較チャート（レーダーチャート、散布図）
  - 資産推移の折れ線グラフ（複数ゲームの平均）
  - 研究論文用HTMLレポートテンプレート
  - PDF出力機能（オプション）

#### 検証項目

- 詳細データが研究に使えるレベルか
- レポートが研究に使えるレベルか

---

### Phase 13: Web UI（オプション）

**目標**: ブラウザベースのインタラクティブなUI

#### 開発ステップ

1. **詳細仕様**: UI/UX仕様、API仕様、画面遷移の定義
2. **設計**: フロントエンドアーキテクチャ、API設計、データフローの設計
3. **実装**: フロントエンド、バックエンドAPI、WebSocketの実装
4. **テスト**: E2Eテスト、APIテスト、UIテスト、パフォーマンステスト

#### 実装範囲
- **フロントエンド**
  - シミュレーション設定画面
  - リアルタイム進捗表示
  - インタラクティブな分析ダッシュボード

- **バックエンドAPI**
  - RESTful API
  - WebSocket（リアルタイム通信）

#### 成果物
- **UI成果物**:
  - シミュレーション設定画面（戦略選択、実行回数設定、パラメータ調整）
  - リアルタイム進捗表示（実行中のゲーム状況、進捗バー）
  - インタラクティブな分析ダッシュボード
    - グラフのズーム・フィルタリング機能
    - データテーブルのソート・検索機能
    - 統計データのドリルダウン
  - 1ゲームの詳細再生機能（ターンごとにボード状態を可視化）
- バックエンドAPI
- API仕様書

---

## マイルストーン

### MVP（最小限の価値提供）
| フェーズ | 期間（想定） | 主要成果物 |
|---------|------------|----------|
| Phase 1 | 3-5日 | 最小限のゲーム実行 |
| Phase 2 | 3-5日 | ゲーム進行の可視化（HTML） |
| Phase 3 | 3-5日 | 複数戦略の実装 |
| Phase 4 | 2-3日 | 結果サマリーレポート |

**MVP完了**: 約2週間

### シミュレーション基盤
| フェーズ | 期間（想定） | 主要成果物 |
|---------|------------|----------|
| Phase 5 | 2-3日 | 複数ゲーム実行 |
| Phase 6 | 3-5日 | 基本統計収集 |
| Phase 7 | 3-5日 | 統計の可視化 |
| Phase 8 | 5-7日 | 並列実行 |

**シミュレーション基盤完了**: 約2-3週間

### 拡張機能
| フェーズ | 期間（想定） | 主要成果物 |
|---------|------------|----------|
| Phase 9 | 5-7日 | 詳細統計 |
| Phase 10 | 1-2週間 | 高度な戦略実装 |
| Phase 11 | 3-5日 | パラメータ調整 |
| Phase 12 | 1-2週間 | 高度な可視化 |
| Phase 13 | 2-4週間 | Web UI（オプション） |

**全機能完了**: 約2-3ヶ月（Phase 13を含む場合）

---

## 各フェーズ後の振り返り

各フェーズ完了時に以下を実施：

1. **動作確認**: 成果物が期待通りに動作するか
2. **アーキテクチャレビュー**: 設計の見直しが必要か
3. **次フェーズの計画調整**: 優先度や実装範囲の再検討
4. **ドキュメント更新**: 学んだことを文書化

---

## アーキテクチャ方針

### アーキテクチャ決定の原則

**全てのアーキテクチャはトレードオフである**

このプロジェクトでは、完璧なアーキテクチャを目指すのではなく、トレードオフを認識し、プロジェクトの価値観に基づいて意思決定を行います。

#### トレードオフを考慮したアーキテクチャ選択

各アーキテクチャ決定において、以下の観点で評価します：

1. **得られるもの**: その選択によって達成できること
2. **失うもの**: その選択によって犠牲になること
3. **判断基準**: プロジェクトの価値観（保守性 > パフォーマンス > 開発速度）に照らして評価
4. **可逆性**: 後で変更可能か、変更コストはどの程度か

#### アーキテクチャ決定の進め方

- **段階的に判断**: Phase 1で全てを決めず、各フェーズで必要な決定を行う
- **実測に基づく**: ベンチマーク、プロファイリング結果で判断する（Phase 8のパフォーマンス評価など）
- **YAGNI重視**: 問題が起きてから解決する。推測で複雑化しない
- **文書化**: 決定理由を記録し、将来の見直しに備える

詳細は [claude.md](../../claude.md) の「アーキテクチャのトレードオフ原則」と [技術選定](technology-selection.md) を参照してください。

### イベント駆動型アーキテクチャ

**Phase 1-12での方針:**
- **イベントログの記録**: ゲーム内の全イベント（サイコロ、購入、レント支払い、破産など）を記録
- **シンプルな実装**: `List<GameEvent>` でイベントを保持し、JSON/CSV形式で保存
- **リアルタイム処理なし**: Phase 1-12では後からイベントログを分析する方式

**イベントログの目的:**
- 後から別の統計分析を追加可能（イベントストリームを再処理）
- ゲームの完全な再生が可能
- Phase 13でリアルタイム分析を追加する際の基盤

**Phase 13以降（オプション）:**
- WebSocket/Server-Sent Eventsでリアルタイムイベント配信
- ブラウザでのリアルタイム進捗表示

### マイクロサービス化

**Phase 1-13での方針:**
- **モノリスアーキテクチャ**: マイクロサービス化は行わない
- **理由**: このプロジェクトの規模ではモノリスで十分、複雑度を避ける

**将来的な拡張（必要になった場合のみ）:**
- ゲームエンジン、統計分析、可視化を独立したサービスに分割
- Kafka/RabbitMQなどのメッセージングシステムの導入
- 現時点では過剰なエンジニアリングと判断

---

## リスクと対策

| リスク | 影響 | 対策 |
|-------|-----|-----|
| パフォーマンス不足 | 大規模シミュレーションが遅い | 早期にベンチマーク、必要に応じて言語やアルゴリズム変更 |
| 戦略の実装が複雑すぎる | 開発遅延 | Phase 1でインターフェースを検証、段階的に複雑化 |
| データ構造の変更コスト | 後戻りが発生 | Phase 1で拡張性を重視、テストで品質担保 |
| スコープクリープ | 完成しない | 各フェーズのスコープを厳守、追加機能は次フェーズへ |

---

## 次のアクション

1. ✅ プロジェクト仕様の策定（完了）
2. ✅ 開発計画の策定（完了）
3. **⏭️ Phase 1 の詳細設計とタスク分解**
4. Phase 1 の実装開始

---

**作成日**: 2025-11-09
**最終更新**: 2025-11-10
