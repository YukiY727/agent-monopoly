# 開発計画

## 開発アプローチ

このプロジェクトは**曳光弾開発（Tracer Bullet Development）** のアプローチを採用します。

### 曳光弾開発を選択する理由

1. **不確実性の高さ**: モノポリーシミュレーション研究という新領域で、実装してみないと分からない要素が多い
2. **早期フィードバック**: 動くものを早期に作り、データ構造や戦略インターフェースの妥当性を検証
3. **段階的な複雑度管理**: シンプルな実装から始め、学習しながら機能を追加
4. **リスク軽減**: 各フェーズで動作するソフトウェアを保持し、後戻りコストを最小化

### 各フェーズでのVモデル適用

各フェーズでは以下のVモデルのサイクルを実施します：

```
詳細仕様 → 設計 → 実装 → テスト
   ↓                        ↑
   └────────────────────────┘
        検証・フィードバック
```

#### 各工程の内容

1. **詳細仕様**: そのフェーズで実装する機能の詳細を定義
2. **設計**: データ構造、モジュール分割、インターフェースを設計
3. **実装**: 設計に基づいてコードを記述
4. **テスト**: ユニットテスト・統合テストで検証し、仕様を満たしているか確認

各フェーズ完了時には、次フェーズに進む前に必ず動作するソフトウェアを保持します。

## 開発フェーズ

### Phase 1: 最小限のゲーム実行

**目標**: 1ゲームを最後まで実行し、勝者を表示できる

#### 開発ステップ

1. **詳細仕様**: 最小限のゲームルール、基本データ構造の仕様化
2. **設計**: コアデータ構造、ゲームループの設計
3. **実装**: 基本ゲームエンジンと1つのシンプルな戦略
4. **テスト**: ゲームが最後まで実行できることを確認

#### 実装範囲
- **最小限のデータ構造**
  - ボード（マス目の基本定義）
  - プレイヤー（所持金、位置）
  - プロパティ（価格、所有者）

- **基本ゲームロジック**
  - サイコロ振り
  - マスの移動
  - 土地の購入判定（常に購入する戦略のみ）
  - 破産判定
  - ゲーム終了条件

- **CLI出力**
  - 勝者の表示のみ

#### 成果物
- 最小限のゲームエンジン
- 1つのシンプルな戦略（常に購入）
- **UI成果物**: CLIで実行して勝者を表示（ターミナル出力）
- 基本的なユニットテスト

#### 検証項目
- ゲームが最後まで実行されるか
- 勝者が正しく判定されるか

---

### Phase 2: ゲーム進行の可視化

**目標**: ゲーム進行を最初から最後まで追跡できるようにする

#### 開発ステップ

1. **詳細仕様**: ログ出力の仕様、記録する情報の定義、HTML表示の仕様
2. **設計**: ログ記録の仕組み、HTML生成の設計
3. **実装**: ログ機能とHTML出力の実装
4. **テスト**: ログとHTML表示が正しく記録されることを確認

#### 実装範囲
- **ログ機能**
  - ターンごとの状態記録
  - 重要なイベント（購入、破産など）の記録
  - テキスト形式での出力

- **HTML可視化**
  - ゲーム進行の全体表示（最初から最後まで）
  - ターンごとのプレイヤー状態（位置、所持金、所有プロパティ）
  - イベント履歴（サイコロの目、購入/レント支払いなど）
  - シンプルなスタイリング

#### 成果物
- ログ記録機能
- **UI成果物**:
  - CLIでゲームログを詳細表示（ターミナル出力）
  - **ブラウザで開けるゲーム進行HTML**（ターンごとの状態とイベント履歴を時系列表示）

#### 検証項目
- ゲームの進行が最初から最後まで追跡できるか
- CLIログから状況が理解できるか
- **ブラウザ上でゲームの流れが確認できるか**

---

### Phase 3: 複数戦略の実装

**目標**: 異なる戦略を比較できるようにする

#### 開発ステップ

1. **詳細仕様**: 戦略インターフェースの定義、各戦略のロジック仕様
2. **設計**: 戦略パターンの設計、戦略切り替えの仕組み
3. **実装**: 2-3種類の戦略実装
4. **テスト**: 各戦略が正しく動作することを確認

#### 実装範囲
- **戦略インターフェース**
  - 戦略の抽象化

- **追加戦略**
  - ランダム戦略（購入をランダムに決定）
  - 保守的戦略（一定額以上の現金を保持）

- **戦略選択機能**
  - CLIで戦略を指定して実行

#### 成果物
- 3種類の戦略
- **UI成果物**: 戦略を指定して実行できるCLI（コマンドライン引数で戦略選択）

#### 検証項目
- 戦略インターフェースが適切か
- 各戦略が異なる挙動を示すか

---

### Phase 4: ゲーム結果サマリーレポート

**目標**: ゲーム結果をサマリー形式で確認できるようにする

#### 開発ステップ

1. **詳細仕様**: 結果サマリーの内容、フォーマットの定義
2. **設計**: サマリーレポート生成の仕組み、テンプレート構造
3. **実装**: 結果サマリー機能の実装
4. **テスト**: ブラウザで表示確認

#### 実装範囲
- **結果サマリー生成**
  - ゲーム結果の要約表示
  - プレイヤー別の最終状態
  - Phase 2の詳細進行表示とは別の、結果に特化したレポート

#### 成果物
- 結果サマリー生成機能
- **UI成果物**:
  - ゲーム結果サマリー表示（勝者、最終順位、ゲーム統計）
  - プレイヤー別の最終資産・所有プロパティ一覧
  - Phase 2の進行表示とは別の、結果確認用HTMLファイル

#### 検証項目
- 結果が一目で理解できるか
- Phase 2の詳細表示と使い分けができるか

---

### Phase 5: 複数ゲーム実行

**目標**: N回のゲームを連続実行できるようにする

#### 開発ステップ

1. **詳細仕様**: 複数実行の仕様、実行回数の指定方法
2. **設計**: ゲーム実行ループの設計
3. **実装**: 複数ゲーム実行機能
4. **テスト**: 指定回数正しく実行されることを確認

#### 実装範囲
- **複数実行機能**
  - N回のゲーム実行
  - 進捗表示（ターミナル）

#### 成果物
- N回実行できるCLI
- **UI成果物**: 実行中の進捗表示（ターミナル出力、プログレスバー）

#### 検証項目
- 指定回数実行されるか
- 各ゲームが独立して実行されるか

---

### Phase 6: 基本統計収集

**目標**: 複数ゲームの結果を集計できるようにする

#### 開発ステップ

1. **詳細仕様**: 統計項目の定義、集計方法の仕様
2. **設計**: 統計データ構造、集計アルゴリズムの設計
3. **実装**: 統計収集機能
4. **テスト**: 統計が正確に計算されることを確認

#### 実装範囲
- **基本統計**
  - 勝率（戦略別）
  - 平均ゲームターン数
  - 平均最終資産額

- **統計出力**
  - JSON/CSV形式での出力

#### 成果物
- 統計収集機能
- **UI成果物**: 統計ファイル出力（JSON/CSV）+ CLIで統計サマリー表示

#### 検証項目
- 統計データが正確か
- ファイル出力が正しいフォーマットか

---

### Phase 7: 統計の可視化

**目標**: 統計結果をグラフで表示できるようにする

#### 開発ステップ

1. **詳細仕様**: グラフの種類、表示項目の定義
2. **設計**: 可視化ライブラリの選定、グラフ生成の設計
3. **実装**: グラフ生成機能
4. **テスト**: グラフが正しく表示されることを確認

#### 実装範囲
- **基本グラフ**
  - 勝率の棒グラフ
  - ゲーム長の分布（ヒストグラム）

- **HTMLレポートへの統合**
  - Phase 4のHTMLレポートにグラフを追加

#### 成果物
- グラフ生成機能
- **UI成果物**:
  - 戦略別勝率の棒グラフ
  - ゲーム長分布のヒストグラム
  - Phase 4のHTMLレポートにグラフセクションを追加
  - インタラクティブではない静的グラフ

#### 検証項目
- グラフが直感的に理解できるか

---

### Phase 8: 並列実行

**目標**: シミュレーションを高速化する

#### 開発ステップ

1. **詳細仕様**: 並列実行の仕様、並列度の定義
2. **設計**: 並列処理の設計、スレッド/プロセス管理
3. **実装**: 並列実行機能
4. **テスト**: パフォーマンステスト、正確性の検証

#### 実装範囲
- **並列実行エンジン**
  - マルチスレッド/マルチプロセス対応
  - 結果の集約

#### 成果物
- 並列実行機能
- パフォーマンス向上
- **UI成果物**: 並列実行時の進捗表示（ターミナル、マルチプログレスバー）

#### 検証項目
- パフォーマンスが向上しているか（目安: 10,000ゲーム/分以上）
- 並列実行でも結果が正確か

---

### Phase 9: 詳細統計の追加

**目標**: より詳細な分析項目を追加する

#### 開発ステップ

1. **詳細仕様**: 追加統計項目の定義
2. **設計**: データ収集の拡張設計
3. **実装**: 詳細統計収集
4. **テスト**: 統計の正確性検証

#### 実装範囲
- **詳細統計**
  - プロパティ別の収益性
  - ターンごとの資産推移
  - 破産タイミング分析

#### 成果物
- 拡張された統計機能
- **UI成果物**:
  - プロパティ別収益性ランキング表
  - ターンごとの資産推移グラフ（各プレイヤー）
  - 破産タイミング分布グラフ
  - HTMLレポートに詳細統計セクションを追加

#### 検証項目
- 詳細データが研究に使えるレベルか

---

### Phase 10: 高度な戦略実装

**目標**: より洗練された戦略を実装する

#### 開発ステップ

1. **詳細仕様**: 各戦略のロジック定義
2. **設計**: 戦略の拡張設計
3. **実装**: 高度な戦略実装
4. **テスト**: 各戦略の動作検証

#### 実装範囲
- **高度な戦略**
  - セット重視戦略（同色セット完成を優先）
  - ROI戦略（投資効率を計算）
  - その他5-10種類

#### 成果物
- 追加の戦略実装（5-10種類）
- **UI成果物**: CLIで全戦略一覧表示 + 各戦略の説明表示機能

#### 検証項目
- 各戦略が期待通りの挙動を示すか

---

### Phase 11: 戦略パラメータ調整

**目標**: 戦略のパラメータを調整できるようにする

#### 開発ステップ

1. **詳細仕様**: パラメータ仕様、設定方法の定義
2. **設計**: パラメータ管理の設計
3. **実装**: パラメータ調整機能
4. **テスト**: パラメータ変更の動作確認

#### 実装範囲
- **パラメータ管理**
  - 設定ファイル（JSON/YAML）
  - パラメータグリッドサーチ

#### 成果物
- パラメータ設定ファイル（JSON/YAML）
- パラメータ最適化ツール
- **UI成果物**: CLIでパラメータ設定を読み込み・表示する機能

#### 検証項目
- パラメータが正しく反映されるか

---

### Phase 12: 高度な可視化

**目標**: 研究レベルのグラフとレポートを生成する

#### 開発ステップ

1. **詳細仕様**: 高度なグラフの仕様、レポートテンプレート
2. **設計**: 可視化コンポーネントの設計
3. **実装**: 高度な可視化機能
4. **テスト**: レポート品質の確認

#### 実装範囲
- **高度なグラフ**
  - 資産推移のグラフ
  - ヒートマップ（マス目の収益性）
  - 戦略別の詳細比較チャート

- **レポート機能**
  - 研究論文レベルのレポート
  - PDF出力（オプション）

#### 成果物
- 高度な可視化機能
- **UI成果物**:
  - ボードマス目のヒートマップ（止まった回数、収益性）
  - 戦略間の詳細比較チャート（レーダーチャート、散布図）
  - 資産推移の折れ線グラフ（複数ゲームの平均）
  - 研究論文用HTMLレポートテンプレート
  - PDF出力機能（オプション）

#### 検証項目
- レポートが研究に使えるレベルか

---

### Phase 13: Web UI（オプション）

**目標**: ブラウザベースのインタラクティブなUI

#### 開発ステップ

1. **詳細仕様**: UI/UX仕様、API仕様、画面遷移の定義
2. **設計**: フロントエンドアーキテクチャ、API設計、データフローの設計
3. **実装**: フロントエンド、バックエンドAPI、WebSocketの実装
4. **テスト**: E2Eテスト、APIテスト、UIテスト、パフォーマンステスト

#### 実装範囲
- **フロントエンド**
  - シミュレーション設定画面
  - リアルタイム進捗表示
  - インタラクティブな分析ダッシュボード

- **バックエンドAPI**
  - RESTful API
  - WebSocket（リアルタイム通信）

#### 成果物
- **UI成果物**:
  - シミュレーション設定画面（戦略選択、実行回数設定、パラメータ調整）
  - リアルタイム進捗表示（実行中のゲーム状況、進捗バー）
  - インタラクティブな分析ダッシュボード
    - グラフのズーム・フィルタリング機能
    - データテーブルのソート・検索機能
    - 統計データのドリルダウン
  - 1ゲームの詳細再生機能（ターンごとにボード状態を可視化）
- バックエンドAPI
- API仕様書

---

## マイルストーン

### MVP（最小限の価値提供）
| フェーズ | 期間（想定） | 主要成果物 |
|---------|------------|----------|
| Phase 1 | 3-5日 | 最小限のゲーム実行 |
| Phase 2 | 3-5日 | ゲーム進行の可視化（HTML） |
| Phase 3 | 3-5日 | 複数戦略の実装 |
| Phase 4 | 2-3日 | 結果サマリーレポート |

**MVP完了**: 約2週間

### シミュレーション基盤
| フェーズ | 期間（想定） | 主要成果物 |
|---------|------------|----------|
| Phase 5 | 2-3日 | 複数ゲーム実行 |
| Phase 6 | 3-5日 | 基本統計収集 |
| Phase 7 | 3-5日 | 統計の可視化 |
| Phase 8 | 5-7日 | 並列実行 |

**シミュレーション基盤完了**: 約2-3週間

### 拡張機能
| フェーズ | 期間（想定） | 主要成果物 |
|---------|------------|----------|
| Phase 9 | 5-7日 | 詳細統計 |
| Phase 10 | 1-2週間 | 高度な戦略実装 |
| Phase 11 | 3-5日 | パラメータ調整 |
| Phase 12 | 1-2週間 | 高度な可視化 |
| Phase 13 | 2-4週間 | Web UI（オプション） |

**全機能完了**: 約2-3ヶ月（Phase 13を含む場合）

---

## 各フェーズ後の振り返り

各フェーズ完了時に以下を実施：

1. **動作確認**: 成果物が期待通りに動作するか
2. **アーキテクチャレビュー**: 設計の見直しが必要か
3. **次フェーズの計画調整**: 優先度や実装範囲の再検討
4. **ドキュメント更新**: 学んだことを文書化

---

## アーキテクチャ方針

### アーキテクチャ決定の原則

**全てのアーキテクチャはトレードオフである**

このプロジェクトでは、完璧なアーキテクチャを目指すのではなく、トレードオフを認識し、プロジェクトの価値観に基づいて意思決定を行います。

#### トレードオフを考慮したアーキテクチャ選択

各アーキテクチャ決定において、以下の観点で評価します：

1. **得られるもの**: その選択によって達成できること
2. **失うもの**: その選択によって犠牲になること
3. **判断基準**: プロジェクトの価値観（保守性 > パフォーマンス > 開発速度）に照らして評価
4. **可逆性**: 後で変更可能か、変更コストはどの程度か

#### アーキテクチャ決定の進め方

- **段階的に判断**: Phase 1で全てを決めず、各フェーズで必要な決定を行う
- **実測に基づく**: ベンチマーク、プロファイリング結果で判断する（Phase 8のパフォーマンス評価など）
- **YAGNI重視**: 問題が起きてから解決する。推測で複雑化しない
- **文書化**: 決定理由を記録し、将来の見直しに備える

詳細は [claude.md](../../claude.md) の「アーキテクチャのトレードオフ原則」と [技術選定](technology-selection.md) を参照してください。

### イベント駆動型アーキテクチャ

**Phase 1-12での方針:**
- **イベントログの記録**: ゲーム内の全イベント（サイコロ、購入、レント支払い、破産など）を記録
- **シンプルな実装**: `List<GameEvent>` でイベントを保持し、JSON/CSV形式で保存
- **リアルタイム処理なし**: Phase 1-12では後からイベントログを分析する方式

**イベントログの目的:**
- 後から別の統計分析を追加可能（イベントストリームを再処理）
- ゲームの完全な再生が可能
- Phase 13でリアルタイム分析を追加する際の基盤

**Phase 13以降（オプション）:**
- WebSocket/Server-Sent Eventsでリアルタイムイベント配信
- ブラウザでのリアルタイム進捗表示

### マイクロサービス化

**Phase 1-13での方針:**
- **モノリスアーキテクチャ**: マイクロサービス化は行わない
- **理由**: このプロジェクトの規模ではモノリスで十分、複雑度を避ける

**将来的な拡張（必要になった場合のみ）:**
- ゲームエンジン、統計分析、可視化を独立したサービスに分割
- Kafka/RabbitMQなどのメッセージングシステムの導入
- 現時点では過剰なエンジニアリングと判断

---

## リスクと対策

| リスク | 影響 | 対策 |
|-------|-----|-----|
| パフォーマンス不足 | 大規模シミュレーションが遅い | 早期にベンチマーク、必要に応じて言語やアルゴリズム変更 |
| 戦略の実装が複雑すぎる | 開発遅延 | Phase 1でインターフェースを検証、段階的に複雑化 |
| データ構造の変更コスト | 後戻りが発生 | Phase 1で拡張性を重視、テストで品質担保 |
| スコープクリープ | 完成しない | 各フェーズのスコープを厳守、追加機能は次フェーズへ |

---

## 次のアクション

1. ✅ プロジェクト仕様の策定（完了）
2. ✅ 開発計画の策定（完了）
3. **⏭️ Phase 1 の詳細設計とタスク分解**
4. Phase 1 の実装開始

---

**作成日**: 2025-11-09
**最終更新**: 2025-11-10
