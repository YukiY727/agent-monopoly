# Phase 8: 並列実行

**目標**: シミュレーションを並列実行で高速化する

---

## 概要

Phase 8では、複数ゲームの実行を並列化し、シミュレーションのパフォーマンスを向上させます。Phase 5で実装した逐次実行を、Kotlin Coroutinesを使って並列実行に拡張します。

---

## 実装範囲

### 1. 並列実行エンジン

**ParallelGameRunner**:
- Kotlin Coroutinesを使用した並列実行
- 設定可能な並列度（デフォルト: CPU コア数）
- 各ゲームの独立実行
- 結果の安全な集約

### 2. 進捗表示の改善

**スレッドセーフな進捗表示**:
- 並列実行中の進捗を正確に表示
- リアルタイム更新
- 完了数/総数の表示

### 3. CLI オプション

**新しいオプション**:
- `--parallel <N>`: 並列度を指定（デフォルト: CPUコア数）
- `--sequential`: 逐次実行を強制（デバッグ用）

---

## 技術選定

### Kotlin Coroutines

**選定理由**:
- Kotlinネイティブのソリューション
- 軽量で効率的（スレッドより少ないオーバーヘッド）
- シンプルなAPI（async/await）
- 構造化並行性でエラーハンドリングが容易

**代替案との比較**:
- Java ExecutorService: より低レベル、Coroutinesの方がシンプル
- Parallel Streams: Kotlinでは標準的でない、制御が難しい

---

## 成果物

1. **ParallelGameRunner クラス**
   - 並列実行エンジン
   - 結果の集約

2. **拡張された CLI**
   - 並列度の指定オプション
   - 進捗表示の改善

3. **パフォーマンステスト**
   - 逐次実行との比較
   - 目標: 10,000ゲーム/分以上

---

## 検証項目

1. **正確性**
   - 並列実行でも結果が正確か
   - 乱数生成が独立しているか

2. **パフォーマンス**
   - 逐次実行と比較して高速化されているか
   - 目標: 10,000ゲーム/分以上（100ゲーム実行で6秒以内）

3. **スケーラビリティ**
   - 並列度を上げると速度が向上するか
   - CPU使用率が適切か

---

## 実装の優先順位

1. **High**: ParallelGameRunner 実装
2. **High**: スレッドセーフな進捗表示
3. **Medium**: CLI オプションの追加
4. **Low**: パフォーマンスベンチマーク

---

## 制約と前提

### 制約

- 各ゲームは完全に独立して実行される
- グローバルな状態共有はない
- メモリ使用量の制限（大量のゲーム実行時）

### 前提

- CPU コア数が2以上
- 各ゲームの実行時間は数百ミリ秒程度
- メモリは十分にある

---

## リスクと対策

| リスク | 影響 | 対策 |
|-------|-----|-----|
| メモリ不足 | 大量ゲーム実行時にOOM | バッチ処理、結果のストリーミング |
| 乱数の競合 | 結果が不正確 | 各ゲームで独立した乱数生成器 |
| デバッグ困難 | 問題の特定が難しい | --sequential オプションで逐次実行可能 |

---

## 次のフェーズへの準備

Phase 9（詳細統計）では、並列実行の結果を詳細に分析します。Phase 8で並列実行基盤を整えることで、大量のゲームデータを効率的に収集できます。

---

**作成日**: 2025-11-16
