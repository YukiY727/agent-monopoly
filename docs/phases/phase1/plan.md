# Phase 1 詳細計画

**フェーズ目標**: 1ゲームを最後まで実行し、勝者を表示できる

**成果物**:
- 最小限のゲームエンジン
- 1つのシンプルな戦略（常に購入）
- CLIで実行して勝者を表示
- 基本的なユニットテスト

---

## L1: Phase 1全体概要

Phase 1では、モノポリーゲームの最小限の実装を行い、エンドツーエンドでゲームが動作することを確認します。

---

## L2: 機能分類

### L2-1: データモデル
ゲームの状態を表現するための基本データ構造

### L2-2: ゲームロジック
ゲームの進行を制御するコアロジック

### L2-3: 戦略システム
プレイヤーの意思決定を抽象化

### L2-4: CLI インターフェース
ゲームの実行と結果表示

### L2-5: テスト
各機能の動作検証

---

## L3: 詳細タスク

### L2-1: データモデル

#### L3-1-1: ボードデータ構造
- **タスク**: Boardクラス/型の定義
- **内容**:
  - マス目の配列（40マス）
  - 各マスの種類（プロパティ、駅、電力会社、税金、チャンス、コミュニティチェスト、GO、刑務所、フリーパーキング、刑務所行き）
  - 各マスの基本情報（名前、位置インデックス）
- **成果物**: `Board` 型/クラス
- **テスト**: ボードが40マス持つこと、各マスが適切な位置にあること

#### L3-1-2: プロパティデータ構造
- **タスク**: Propertyクラス/型の定義
- **内容**:
  - プロパティ名
  - 購入価格
  - レント（家なし）
  - 所有者（Playerへの参照、または null）
  - 色グループ（Phase 1では使用しないが、拡張性のため定義）
- **成果物**: `Property` 型/クラス
- **テスト**: プロパティの初期化、価格設定が正しいこと

#### L3-1-3: プレイヤーデータ構造
- **タスク**: Playerクラス/型の定義
- **内容**:
  - プレイヤー名
  - 現在位置（0-39のインデックス）
  - 所持金（初期値: 1500）
  - 所有プロパティリスト
  - 破産フラグ
  - 戦略への参照
- **成果物**: `Player` 型/クラス
- **テスト**: プレイヤーの初期化、所持金が1500であること

#### L3-1-4: ゲーム状態データ構造
- **タスク**: GameStateクラス/型の定義
- **内容**:
  - ボードへの参照
  - プレイヤーリスト（2-4人）
  - 現在のターン番号
  - 現在のプレイヤー
  - ゲーム終了フラグ
- **成果物**: `GameState` 型/クラス
- **テスト**: ゲーム状態の初期化、プレイヤー追加

---

### L2-2: ゲームロジック

#### L3-2-1: サイコロ機能
- **タスク**: サイコロを振る関数
- **内容**:
  - 2つのサイコロ（1-6）を振る
  - 合計値を返す
  - Phase 1ではゾロ目は無視（シンプル化）
- **成果物**: `rollDice()` 関数
- **テスト**: サイコロの値が2-12の範囲であること

#### L3-2-2: プレイヤー移動機能
- **タスク**: プレイヤーを移動させる関数
- **内容**:
  - 現在位置 + サイコロの目 → 新しい位置（mod 40）
  - GO通過判定（位置が一周した場合、200追加）
  - プレイヤーの位置を更新
- **成果物**: `movePlayer(player, diceValue)` 関数
- **テスト**: 移動が正しく行われること、GO通過で200もらえること

#### L3-2-3: マス目処理
- **タスク**: プレイヤーが止まったマスの処理
- **内容**:
  - マスがプロパティの場合:
    - 所有者がいない → 購入判定（戦略に委譲）
    - 所有者がいる（他プレイヤー） → レント支払い
    - 所有者が自分 → 何もしない
  - Phase 1では、プロパティ以外のマス（税金、チャンスなど）は無視
- **成果物**: `processSpace(player, space)` 関数
- **テスト**: 各ケースが正しく処理されること

#### L3-2-4: プロパティ購入処理
- **タスク**: プロパティを購入する関数
- **内容**:
  - プレイヤーの所持金から購入価格を引く
  - プロパティの所有者をプレイヤーに設定
  - プレイヤーの所有プロパティリストに追加
- **成果物**: `buyProperty(player, property)` 関数
- **テスト**: 購入後、所持金が減り、所有プロパティが増えること

#### L3-2-5: レント支払い処理
- **タスク**: レントを支払う関数
- **内容**:
  - プレイヤーの所持金からレントを引く
  - 所有者の所持金にレントを加える
  - 支払い後、所持金が負になったら破産処理
- **成果物**: `payRent(player, owner, rent)` 関数
- **テスト**: レント支払い後、所持金が正しく増減すること

#### L3-2-6: 破産処理
- **タスク**: プレイヤーを破産させる関数
- **内容**:
  - プレイヤーの破産フラグを立てる
  - プレイヤーの所有プロパティを全て未所有に戻す
- **成果物**: `bankruptPlayer(player)` 関数
- **テスト**: 破産後、所有プロパティがすべて解放されること

#### L3-2-7: ゲーム終了判定
- **タスク**: ゲーム終了条件をチェックする関数
- **内容**:
  - 破産していないプレイヤーが1人以下 → ゲーム終了
  - 勝者を決定（残っているプレイヤー、または最も資産が多いプレイヤー）
- **成果物**: `checkGameEnd(gameState)` 関数
- **テスト**: 1人残った時点でゲーム終了すること

#### L3-2-8: ターン実行
- **タスク**: 1ターンを実行する関数
- **内容**:
  - サイコロを振る
  - プレイヤーを移動
  - マス目処理
  - ゲーム終了判定
  - 次のプレイヤーに交代（破産していないプレイヤー）
- **成果物**: `executeTurn(gameState)` 関数
- **テスト**: 1ターンで期待通りの状態変化が起きること

#### L3-2-9: ゲームループ
- **タスク**: ゲーム全体を実行する関数
- **内容**:
  - ゲーム状態を初期化
  - ゲーム終了まで `executeTurn` を繰り返す
  - 勝者を返す
  - 無限ループ防止（最大ターン数: 1000）
- **成果物**: `runGame(players)` 関数
- **テスト**: ゲームが最後まで実行され、勝者が返されること

---

### L2-3: 戦略システム

#### L3-3-1: 戦略インターフェース
- **タスク**: Strategy インターフェース/型の定義
- **内容**:
  - `shouldBuyProperty(player, property, gameState): boolean` メソッド
- **成果物**: `Strategy` インターフェース
- **テスト**: インターフェースが定義されていること

#### L3-3-2: AlwaysBuy戦略
- **タスク**: 常に購入する戦略の実装
- **内容**:
  - `shouldBuyProperty` が常に `true` を返す
  - ただし、所持金が購入価格より少ない場合は `false`
- **成果物**: `AlwaysBuyStrategy` クラス
- **テスト**: 購入可能な場合は true、不可能な場合は false を返すこと

---

### L2-4: CLI インターフェース

#### L3-4-1: エントリーポイント
- **タスク**: CLIのメイン関数
- **内容**:
  - ゲームを実行
  - 勝者を表示
  - Phase 1では引数なし（固定で2プレイヤー、AlwaysBuy戦略）
- **成果物**: `main()` 関数または `index.ts`
- **テスト**: 手動テスト（実行して勝者が表示されること）

#### L3-4-2: 結果表示
- **タスク**: 勝者を表示する関数
- **内容**:
  - 勝者のプレイヤー名
  - 最終所持金
  - 所有プロパティ数
- **成果物**: `displayResult(winner)` 関数
- **テスト**: 手動テスト（表示が見やすいこと）

---

### L2-5: テスト

#### L3-5-1: データモデルのユニットテスト
- **タスク**: Board, Property, Player, GameState のテスト
- **内容**:
  - 各データ構造の初期化
  - 基本的なプロパティアクセス
- **成果物**: `*.test.ts` ファイル
- **テスト**: すべてのテストがパス

#### L3-5-2: ゲームロジックのユニットテスト
- **タスク**: サイコロ、移動、マス目処理、購入、レント、破産のテスト
- **内容**:
  - 各関数が期待通りの動作をすること
  - エッジケース（所持金0、破産、GO通過など）
- **成果物**: `*.test.ts` ファイル
- **テスト**: すべてのテストがパス

#### L3-5-3: 統合テスト
- **タスク**: ゲーム全体の実行テスト
- **内容**:
  - `runGame` を実行し、ゲームが終了すること
  - 勝者が返されること
  - 無限ループにならないこと
- **成果物**: `game.test.ts`
- **テスト**: 複数回実行してすべて成功すること

---

## タスクの優先順位

### 必須タスク（Phase 1 完了に必要）
1. L3-1-1 ~ L3-1-4: データモデルすべて
2. L3-2-1 ~ L3-2-9: ゲームロジックすべて
3. L3-3-1 ~ L3-3-2: 戦略システム
4. L3-4-1 ~ L3-4-2: CLI
5. L3-5-1 ~ L3-5-3: テスト

### 推奨実装順序

1. **データモデル** (L3-1-1 ~ L3-1-4) - まず型を定義
2. **サイコロ** (L3-2-1) - 最もシンプルな機能から
3. **移動** (L3-2-2) - サイコロと組み合わせ
4. **戦略インターフェース** (L3-3-1, L3-3-2) - 購入判定に必要
5. **購入処理** (L3-2-4) - 戦略を使う
6. **レント支払い** (L3-2-5) - ゲームの核心
7. **破産処理** (L3-2-6) - レントと組み合わせ
8. **マス目処理** (L3-2-3) - 購入・レント・破産を統合
9. **ゲーム終了判定** (L3-2-7) - ループ終了条件
10. **ターン実行** (L3-2-8) - すべてを統合
11. **ゲームループ** (L3-2-9) - 最終統合
12. **CLI** (L3-4-1, L3-4-2) - ユーザー向けインターフェース
13. **テスト** (L3-5-1 ~ L3-5-3) - 並行して実装、最後に完全性確認

---

## 見積もり

| タスク分類 | 想定時間 |
|-----------|---------|
| L2-1: データモデル | 2-4時間 |
| L2-2: ゲームロジック | 8-12時間 |
| L2-3: 戦略システム | 1-2時間 |
| L2-4: CLI | 1-2時間 |
| L2-5: テスト | 4-6時間 |
| **合計** | **16-26時間（3-5日）** |

---

## 次のアクション

1. **環境セットアップ** (別途実施)
   - package.json作成
   - TypeScript設定
   - Vitest設定
   - Biome設定

2. **Phase 1 実装開始**
   - L3-1-1から順に実装
   - 各タスク完了ごとにテスト
   - 動作確認しながら進める

---

**作成日**: 2025-11-10
**最終更新**: 2025-11-10
