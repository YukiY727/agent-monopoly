# Phase 2 詳細計画

**フェーズ目標**: ゲーム進行を最初から最後まで追跡できるようにする

**成果物**:
- イベントログ記録システム
- CLIでの詳細なゲームログ表示
- ブラウザで閲覧可能なHTML可視化
- Phase 1コードのリファクタリング（柔軟性重視）

**重要方針**:
- **Phase 1のコードも柔軟に書き換える**
- Phase 2の要件に合わせて、Phase 1の設計を改善する
- 後方互換性よりも、正しい設計を優先する
- テストコードも必要に応じて更新する

---

## ⚠️ この計画書の位置づけ

**このドキュメントに書かれているタスク分解や実装内容は「出発点」であり、「確定仕様」ではありません。**

### TDDでの柔軟な計画変更

このドキュメントには詳細なタスク分解（L3-1-1、L3-1-2など）と具体的な実装内容が記載されていますが、これらは：

- ✅ **実装の出発点**として活用する
- ✅ **実装中に不要と判断したタスクはスキップする**
- ✅ **新たに必要なタスクが見つかれば追加する**
- ✅ **実装順序も柔軟に変更する**
- ❌ **この通りに実装しなければならない**わけではない

### 実装中の判断例

```
例1: L3-1-3「イベントログのJSON出力」
→ 実装中に「Phase 2ではJSON出力は不要」と判断したらスキップ可能

例2: L3-2-1「GameServiceへのイベント記録追加」
→ 実装中に「EventRecorderクラスに分離した方が良い」と判断したら変更

例3: 実装順序の変更
→ ドキュメントでは「イベント型定義→GameState拡張→GameService改修」
→ 実装中に「GameService改修→GameState拡張→イベント型定義」の方が良いと判断したら変更
```

**TDDのテストを書きながら、最適なタスク分解と実装順序を見つける。**

---

## L1: Phase 2全体概要

Phase 2では、ゲームの進行状況を記録・可視化する機能を追加します。これにより、ゲームの流れを最初から最後まで詳細に追跡できるようになります。

### Phase 1コードの柔軟な改修方針

Phase 2の実装にあたり、Phase 1で書いたコードを以下の方針で改修します：

1. **イベント駆動設計への移行**
   - Phase 1のGameServiceなどに、イベント記録ロジックを追加
   - 既存メソッドにイベント発火処理を組み込む
   - 必要に応じてメソッドシグネチャを変更

2. **ドメインモデルの拡張**
   - GameStateにイベントログを保持する機能を追加
   - PlayerやPropertyクラスに、状態変化を記録するフックを追加
   - 既存のdata classをより柔軟な設計に変更

3. **テストコードの更新**
   - イベント記録機能を検証するテストを追加
   - 既存テストがイベント記録の影響を受ける場合は修正
   - Phase 1のテストは可能な限り維持しつつ、必要に応じて更新

4. **リファクタリングの優先**
   - Phase 2の実装を進める中で、Phase 1のコードの問題点が見つかった場合は積極的に修正
   - "動作するコード"よりも"保守しやすいコード"を優先
   - 技術的負債を残さない

---

## L2: 機能分類

### L2-1: イベントログシステム
ゲーム内のすべてのイベントを記録する仕組み

### L2-2: Phase 1コードの改修
既存コードにイベント記録機能を組み込む

### L2-3: CLIログ表示
ターミナルでゲーム進行を詳細に表示

### L2-4: HTML可視化
ブラウザでゲーム進行を視覚的に確認

### L2-5: テスト
イベント記録と可視化のテスト

---

## L3: 詳細タスク

### L2-1: イベントログシステム

#### L3-1-1: イベント型定義
- **タスク**: GameEventのsealed classを定義
- **内容**:
  - `DiceRolled`: サイコロの結果
  - `PlayerMoved`: プレイヤー移動（GO通過含む)
  - `PropertyPurchased`: プロパティ購入
  - `RentPaid`: レント支払い
  - `PlayerBankrupted`: 破産
  - `GameStarted`: ゲーム開始
  - `GameEnded`: ゲーム終了
  - `TurnStarted`: ターン開始
  - `TurnEnded`: ターン終了
- **成果物**: `GameEvent` sealed class（各イベント型は必要な情報を保持）
- **Phase 1への影響**: 新規追加、既存コードへの影響なし
- **テスト**: イベント型が正しく初期化できること

#### L3-1-2: イベントログ記録機能
- **タスク**: GameStateにイベントログを追加
- **内容**:
  - `val events: MutableList<GameEvent>` をGameStateに追加
  - `fun recordEvent(event: GameEvent)` メソッドを追加
  - イベントにタイムスタンプ（ターン番号）を含める
- **成果物**: 拡張されたGameState
- **Phase 1への影響**: GameStateの構造を変更（既存コンストラクタは維持）
- **テスト**: イベントが記録されること、順序が保持されること

#### L3-1-3: イベントログのJSON出力
- **タスク**: イベントログをJSON形式で保存
- **内容**:
  - kotlinx.serialization を使用
  - イベントログを`game-log-{timestamp}.json` として出力
- **成果物**: `EventLogger` クラス
- **Phase 1への影響**: なし（新規機能）
- **テスト**: JSON出力が正しいフォーマットであること

---

### L2-2: Phase 1コードの改修

#### L3-2-1: GameServiceへのイベント記録追加
- **タスク**: 既存のGameServiceメソッドにイベント記録を組み込む
- **内容**:
  - `movePlayer`: 移動後に`PlayerMoved`イベントを記録
  - `buyProperty`: 購入後に`PropertyPurchased`イベントを記録
  - `payRent`: 支払い後に`RentPaid`イベントを記録
  - `bankruptPlayer`: 破産後に`PlayerBankrupted`イベントを記録
  - `executeTurn`: ターン開始/終了イベントを記録
  - `runGame`: ゲーム開始/終了イベントを記録
- **成果物**: イベント記録機能を持つGameService
- **Phase 1への影響**: **GameServiceの実装を直接変更**
- **テスト**: 各メソッド実行後、対応するイベントが記録されていること

#### L3-2-2: Diceへのイベント記録追加
- **タスク**: サイコロ結果をイベントとして記録
- **内容**:
  - `roll()` メソッドにイベント記録を追加
  - またはGameServiceの`executeTurn`でサイコロ結果を記録
- **成果物**: イベント記録を持つDice または GameService
- **Phase 1への影響**: **Diceの実装を変更、またはGameServiceを変更**
- **テスト**: サイコロを振ると`DiceRolled`イベントが記録されること

#### L3-2-3: 既存テストの更新
- **タスク**: Phase 1のテストコードをイベント記録に対応させる
- **内容**:
  - GameStateのコンストラクタが変更された場合、テストを更新
  - イベント記録が原因でテストが失敗する場合は修正
  - 必要に応じてモック/スタブを導入
- **成果物**: 更新されたテストコード
- **Phase 1への影響**: **Phase 1のテストコードを直接変更**
- **テスト**: Phase 1の全テストがパスすること

---

### L2-3: CLIログ表示

#### L3-3-1: ターンごとのログ出力
- **タスク**: ゲーム進行をCLIに詳細表示
- **内容**:
  - ターン番号、現在のプレイヤー、サイコロの目を表示
  - 移動先、GO通過、購入/レント支払いなどのアクションを表示
  - 各プレイヤーの現在の状態（位置、所持金、所有プロパティ）を表示
- **成果物**: `ConsoleLogger` クラス
- **Phase 1への影響**: なし（新規機能、MonopolyGameのmainから呼び出す）
- **テスト**: 手動テスト（実行して見やすいか確認）

#### L3-3-2: イベントハイライト表示
- **タスク**: 重要なイベント（購入、破産など）を目立たせる
- **内容**:
  - ANSI カラーコードを使用（緑=購入、赤=破産、黄=レント支払いなど）
  - または記号（⭐、❗、💰など）を使用
- **成果物**: カラー/記号付きログ表示
- **Phase 1への影響**: なし
- **テスト**: 手動テスト（表示が見やすいか）

---

### L2-4: HTML可視化

#### L3-4-1: HTMLテンプレート設計
- **タスク**: ゲーム進行を表示するHTMLテンプレートを設計
- **内容**:
  - ヘッダー: ゲーム情報（プレイヤー名、戦略、開始時刻）
  - サマリー: 最終結果（勝者、ゲーム長、プレイヤー別最終状態）
  - タイムライン: ターンごとの詳細表示
  - イベントログ: すべてのイベントを時系列表示
  - シンプルなCSS（見やすさ重視、デザイン凝らない）
- **成果物**: HTMLテンプレート構造の設計書（Markdown）
- **Phase 1への影響**: なし
- **テスト**: 手動テスト（ブラウザで表示して確認）

#### L3-4-2: HTML生成ロジック
- **タスク**: イベントログからHTMLを生成
- **内容**:
  - `HtmlReportGenerator` クラスを作成
  - イベントログを読み取り、HTML文字列を生成
  - `game-report-{timestamp}.html` として出力
  - kotlinx.html または文字列連結で実装
- **成果物**: `HtmlReportGenerator` クラス
- **Phase 1への影響**: なし（新規機能）
- **テスト**: HTML出力が正しいフォーマットであること

#### L3-4-3: プレイヤー状態の視覚化
- **タスク**: 各ターンのプレイヤー状態をテーブル表示
- **内容**:
  - プレイヤー名、位置、所持金、所有プロパティ数をテーブルで表示
  - 破産したプレイヤーはグレーアウト
  - 現在のプレイヤーをハイライト
- **成果物**: HTMLテーブル生成機能
- **Phase 1への影響**: なし
- **テスト**: 手動テスト（表示が正しいか）

#### L3-4-4: イベント履歴の表示
- **タスク**: イベントを時系列で表示
- **内容**:
  - ターン番号、イベント種類、詳細をリスト表示
  - 重要なイベントをアイコンで表示
  - フィルタリング機能（オプション、時間があれば）
- **成果物**: イベント履歴表示機能
- **Phase 1への影響**: なし
- **テスト**: 手動テスト（表示が見やすいか）

---

### L2-5: テスト

#### L3-5-1: イベントログのユニットテスト
- **タスク**: イベント記録機能のテスト
- **内容**:
  - GameStateにイベントを記録できること
  - イベントが正しい順序で記録されること
  - 各イベント型が正しい情報を保持すること
- **成果物**: `GameEventTest.kt`
- **Phase 1への影響**: なし（新規テスト）
- **テスト**: すべてのテストがパス

#### L3-5-2: GameServiceのイベント記録テスト
- **タスク**: GameServiceの各メソッドがイベントを記録することをテスト
- **内容**:
  - `movePlayer` 実行後、`PlayerMoved` イベントが記録されること
  - `buyProperty` 実行後、`PropertyPurchased` イベントが記録されること
  - その他すべてのメソッドについて同様にテスト
- **成果物**: 更新された `GameServiceTest.kt`
- **Phase 1への影響**: **Phase 1のGameServiceTestに新しいテストを追加**
- **テスト**: すべてのテストがパス

#### L3-5-3: HTML生成のテスト
- **タスク**: HTML生成機能のテスト
- **内容**:
  - イベントログからHTMLが生成されること
  - 生成されたHTMLに必要な要素が含まれること（タイトル、テーブル、イベントリスト）
  - 手動テスト: ブラウザで開いて表示確認
- **成果物**: `HtmlReportGeneratorTest.kt`
- **Phase 1への影響**: なし
- **テスト**: すべてのテストがパス、手動テストで表示確認

#### L3-5-4: 統合テスト
- **タスク**: ゲーム全体を実行してイベントログとHTMLが生成されることを確認
- **内容**:
  - `runGame` を実行
  - イベントログが記録されていること
  - JSON/HTMLファイルが出力されること
  - 手動テスト: HTMLをブラウザで開いてゲームの流れを確認
- **成果物**: `Phase2IntegrationTest.kt`
- **Phase 1への影響**: なし
- **テスト**: 統合テストがパス、手動テストで確認

---

## タスクの優先順位

### 必須タスク（Phase 2 完了に必要）
1. L3-1-1 ~ L3-1-3: イベントログシステム
2. L3-2-1 ~ L3-2-3: Phase 1コードの改修
3. L3-3-1 ~ L3-3-2: CLIログ表示
4. L3-4-1 ~ L3-4-4: HTML可視化
5. L3-5-1 ~ L3-5-4: テスト

### 推奨実装順序

1. **イベント型定義** (L3-1-1) - まずイベントの型を決める
2. **GameStateへのイベントログ追加** (L3-1-2) - イベント記録の基盤
3. **GameServiceの改修** (L3-2-1, L3-2-2) - Phase 1コードにイベント記録を組み込む
4. **既存テストの更新** (L3-2-3) - Phase 1のテストを修正
5. **イベントログのテスト** (L3-5-1, L3-5-2) - イベント記録が正しく動作することを確認
6. **CLIログ表示** (L3-3-1, L3-3-2) - まず簡易的に動作確認
7. **JSONログ出力** (L3-1-3) - イベントログをファイルに保存
8. **HTML生成** (L3-4-1 ~ L3-4-4) - 可視化機能
9. **HTML生成テスト** (L3-5-3) - HTML生成が正しいか確認
10. **統合テスト** (L3-5-4) - 全体が動作することを確認

---

## 見積もり

| タスク分類 | 想定時間 |
|-----------|---------|
| L2-1: イベントログシステム | 3-5時間 |
| L2-2: Phase 1コードの改修 | 4-6時間 |
| L2-3: CLIログ表示 | 2-3時間 |
| L2-4: HTML可視化 | 4-6時間 |
| L2-5: テスト | 3-5時間 |
| **合計** | **16-25時間（3-5日）** |

---

## Phase 1コードの改修に関する注意事項

### 柔軟な設計変更を推奨

Phase 2の実装を通じて、以下のような設計改善が必要になる可能性があります：

1. **GameStateの拡張**
   - イベントログを保持するため、GameStateにフィールドを追加
   - 既存のコンストラクタは維持するが、デフォルト引数でイベントログを初期化

2. **GameServiceの責務の見直し**
   - イベント記録をGameServiceに持たせるか、別のEventRecorderに分離するか検討
   - Phase 2実装中に判断し、必要なら大胆にリファクタリング

3. **Immutabilityとの兼ね合い**
   - Phase 1で`data class`でimmutableにした部分も、必要なら`var`や`MutableList`に変更
   - イベントログは追記型なので、`MutableList`が自然

4. **テストの修正**
   - Phase 1のテストがイベント記録の影響で失敗する場合は、テストを更新
   - イベント記録をモックするか、実際にイベントが記録されていることを検証するか判断

### リファクタリングの自由度

- **Phase 1のコードは神聖視しない**
- **Phase 2の要件に合わせて、Phase 1のコードを積極的に改善する**
- **"動作するコード"よりも"保守しやすいコード"を優先**
- **技術的負債を残さない**

---

## 次のアクション

1. **Phase 2設計レビュー**
   - このドキュメントをレビュー
   - イベント型の設計を確認

2. **Phase 2実装開始**
   - L3-1-1からTDD開始
   - Phase 1のコードを柔軟に改修しながら進める

---

**作成日**: 2025-11-15
**最終更新**: 2025-11-15
