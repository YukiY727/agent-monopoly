# 開発計画

## 開発アプローチ

このプロジェクトは**曳光弾開発（Tracer Bullet Development）** のアプローチを採用します。

### 曳光弾開発を選択する理由

1. **不確実性の高さ**: モノポリーシミュレーション研究という新領域で、実装してみないと分からない要素が多い
2. **早期フィードバック**: 動くものを早期に作り、データ構造や戦略インターフェースの妥当性を検証
3. **段階的な複雑度管理**: シンプルな実装から始め、学習しながら機能を追加
4. **リスク軽減**: 各フェーズで動作するソフトウェアを保持し、後戻りコストを最小化

### 各フェーズでのVモデル適用

各フェーズでは以下のVモデルのサイクルを実施します：

```
詳細仕様 → 設計 → 実装 → テスト
   ↓                        ↑
   └────────────────────────┘
        検証・フィードバック
```

#### 各工程の内容

1. **詳細仕様**: そのフェーズで実装する機能の詳細を定義
2. **設計**: データ構造、モジュール分割、インターフェースを設計
3. **実装**: 設計に基づいてコードを記述
4. **テスト**: ユニットテスト・統合テストで検証し、仕様を満たしているか確認

各フェーズ完了時には、次フェーズに進む前に必ず動作するソフトウェアを保持します。

## 開発フェーズ

### Phase 1: 最小限のゲーム実行

**目標**: 1ゲームを最後まで実行し、勝者を表示できる

#### 開発ステップ

1. **詳細仕様**: 最小限のゲームルール、基本データ構造の仕様化
2. **設計**: コアデータ構造、ゲームループの設計
3. **実装**: 基本ゲームエンジンと1つのシンプルな戦略
4. **テスト**: ゲームが最後まで実行できることを確認

#### 実装範囲
- **最小限のデータ構造**
  - ボード（マス目の基本定義）
  - プレイヤー（所持金、位置）
  - プロパティ（価格、所有者）

- **基本ゲームロジック**
  - サイコロ振り
  - マスの移動
  - 土地の購入判定（常に購入する戦略のみ）
  - 破産判定
  - ゲーム終了条件

- **CLI出力**
  - 勝者の表示のみ

#### 成果物
- 最小限のゲームエンジン
- 1つのシンプルな戦略（常に購入）
- CLIで実行して勝者を表示
- 基本的なユニットテスト

#### 検証項目
- ゲームが最後まで実行されるか
- 勝者が正しく判定されるか

---

### Phase 2: ゲームログの追加

**目標**: ゲーム進行を追跡できるようにする

#### 開発ステップ

1. **詳細仕様**: ログ出力の仕様、記録する情報の定義
2. **設計**: ログ記録の仕組み、出力フォーマットの設計
3. **実装**: ログ機能の実装
4. **テスト**: ログが正しく記録されることを確認

#### 実装範囲
- **ログ機能**
  - ターンごとの状態記録
  - 重要なイベント（購入、破産など）の記録
  - テキスト形式での出力

#### 成果物
- ログ記録機能
- CLIでゲームログを表示

#### 検証項目
- ゲームの進行が追跡できるか
- ログから状況が理解できるか

---

### Phase 3: 複数戦略の実装

**目標**: 異なる戦略を比較できるようにする

#### 開発ステップ

1. **詳細仕様**: 戦略インターフェースの定義、各戦略のロジック仕様
2. **設計**: 戦略パターンの設計、戦略切り替えの仕組み
3. **実装**: 2-3種類の戦略実装
4. **テスト**: 各戦略が正しく動作することを確認

#### 実装範囲
- **戦略インターフェース**
  - 戦略の抽象化

- **追加戦略**
  - ランダム戦略（購入をランダムに決定）
  - 保守的戦略（一定額以上の現金を保持）

- **戦略選択機能**
  - CLIで戦略を指定して実行

#### 成果物
- 3種類の戦略
- 戦略を指定して実行できるCLI

#### 検証項目
- 戦略インターフェースが適切か
- 各戦略が異なる挙動を示すか

---

### Phase 4: 簡易HTMLレポート

**目標**: ブラウザでゲーム結果を確認できるようにする

#### 開発ステップ

1. **詳細仕様**: HTMLレポートの内容、フォーマットの定義
2. **設計**: レポート生成の仕組み、テンプレート構造
3. **実装**: HTML生成機能
4. **テスト**: ブラウザで表示確認

#### 実装範囲
- **HTMLレポート生成**
  - ゲーム結果の表示
  - プレイヤー別の最終状態
  - 簡単なスタイリング

#### 成果物
- HTMLレポート生成機能
- ブラウザで開ける結果ファイル

#### 検証項目
- ブラウザで結果が見やすく表示されるか

---

### Phase 5: 複数ゲーム実行

**目標**: N回のゲームを連続実行できるようにする

#### 開発ステップ

1. **詳細仕様**: 複数実行の仕様、実行回数の指定方法
2. **設計**: ゲーム実行ループの設計
3. **実装**: 複数ゲーム実行機能
4. **テスト**: 指定回数正しく実行されることを確認

#### 実装範囲
- **複数実行機能**
  - N回のゲーム実行
  - 進捗表示（ターミナル）

#### 成果物
- N回実行できるCLI
- 実行中の進捗表示

#### 検証項目
- 指定回数実行されるか
- 各ゲームが独立して実行されるか

---

### Phase 6: 基本統計収集

**目標**: 複数ゲームの結果を集計できるようにする

#### 開発ステップ

1. **詳細仕様**: 統計項目の定義、集計方法の仕様
2. **設計**: 統計データ構造、集計アルゴリズムの設計
3. **実装**: 統計収集機能
4. **テスト**: 統計が正確に計算されることを確認

#### 実装範囲
- **基本統計**
  - 勝率（戦略別）
  - 平均ゲームターン数
  - 平均最終資産額

- **統計出力**
  - JSON/CSV形式での出力

#### 成果物
- 統計収集機能
- 統計ファイル出力

#### 検証項目
- 統計データが正確か
- ファイル出力が正しいフォーマットか

---

### Phase 7: 統計の可視化

**目標**: 統計結果をグラフで表示できるようにする

#### 開発ステップ

1. **詳細仕様**: グラフの種類、表示項目の定義
2. **設計**: 可視化ライブラリの選定、グラフ生成の設計
3. **実装**: グラフ生成機能
4. **テスト**: グラフが正しく表示されることを確認

#### 実装範囲
- **基本グラフ**
  - 勝率の棒グラフ
  - ゲーム長の分布（ヒストグラム）

- **HTMLレポートへの統合**
  - Phase 4のHTMLレポートにグラフを追加

#### 成果物
- グラフ付きHTMLレポート

#### 検証項目
- グラフが直感的に理解できるか

---

### Phase 8: 並列実行

**目標**: シミュレーションを高速化する

#### 開発ステップ

1. **詳細仕様**: 並列実行の仕様、並列度の定義
2. **設計**: 並列処理の設計、スレッド/プロセス管理
3. **実装**: 並列実行機能
4. **テスト**: パフォーマンステスト、正確性の検証

#### 実装範囲
- **並列実行エンジン**
  - マルチスレッド/マルチプロセス対応
  - 結果の集約

#### 成果物
- 並列実行機能
- パフォーマンス向上

#### 検証項目
- パフォーマンスが向上しているか（目安: 10,000ゲーム/分以上）
- 並列実行でも結果が正確か

---

### Phase 9: 詳細統計の追加

**目標**: より詳細な分析項目を追加する

#### 開発ステップ

1. **詳細仕様**: 追加統計項目の定義
2. **設計**: データ収集の拡張設計
3. **実装**: 詳細統計収集
4. **テスト**: 統計の正確性検証

#### 実装範囲
- **詳細統計**
  - プロパティ別の収益性
  - ターンごとの資産推移
  - 破産タイミング分析

#### 成果物
- 拡張された統計機能
- 詳細レポート

#### 検証項目
- 詳細データが研究に使えるレベルか

---

### Phase 10: 高度な戦略実装

**目標**: より洗練された戦略を実装する

#### 開発ステップ

1. **詳細仕様**: 各戦略のロジック定義
2. **設計**: 戦略の拡張設計
3. **実装**: 高度な戦略実装
4. **テスト**: 各戦略の動作検証

#### 実装範囲
- **高度な戦略**
  - セット重視戦略（同色セット完成を優先）
  - ROI戦略（投資効率を計算）
  - その他5-10種類

#### 成果物
- 追加の戦略実装（5-10種類）

#### 検証項目
- 各戦略が期待通りの挙動を示すか

---

### Phase 11: 戦略パラメータ調整

**目標**: 戦略のパラメータを調整できるようにする

#### 開発ステップ

1. **詳細仕様**: パラメータ仕様、設定方法の定義
2. **設計**: パラメータ管理の設計
3. **実装**: パラメータ調整機能
4. **テスト**: パラメータ変更の動作確認

#### 実装範囲
- **パラメータ管理**
  - 設定ファイル（JSON/YAML）
  - パラメータグリッドサーチ

#### 成果物
- パラメータ設定ファイル
- パラメータ最適化ツール

#### 検証項目
- パラメータが正しく反映されるか

---

### Phase 12: 高度な可視化

**目標**: 研究レベルのグラフとレポートを生成する

#### 開発ステップ

1. **詳細仕様**: 高度なグラフの仕様、レポートテンプレート
2. **設計**: 可視化コンポーネントの設計
3. **実装**: 高度な可視化機能
4. **テスト**: レポート品質の確認

#### 実装範囲
- **高度なグラフ**
  - 資産推移のグラフ
  - ヒートマップ（マス目の収益性）
  - 戦略別の詳細比較チャート

- **レポート機能**
  - 研究論文レベルのレポート
  - PDF出力（オプション）

#### 成果物
- 高度な可視化機能
- 研究用レポートテンプレート

#### 検証項目
- レポートが研究に使えるレベルか

---

### Phase 13: Web UI（オプション）

**目標**: ブラウザベースのインタラクティブなUI

#### 開発ステップ

1. **詳細仕様**: UI/UX仕様、API仕様、画面遷移の定義
2. **設計**: フロントエンドアーキテクチャ、API設計、データフローの設計
3. **実装**: フロントエンド、バックエンドAPI、WebSocketの実装
4. **テスト**: E2Eテスト、APIテスト、UIテスト、パフォーマンステスト

#### 実装範囲
- **フロントエンド**
  - シミュレーション設定画面
  - リアルタイム進捗表示
  - インタラクティブな分析ダッシュボード

- **バックエンドAPI**
  - RESTful API
  - WebSocket（リアルタイム通信）

#### 成果物
- Webアプリケーション
- API仕様書

---

## マイルストーン

### MVP（最小限の価値提供）
| フェーズ | 期間（想定） | 主要成果物 |
|---------|------------|----------|
| Phase 1 | 3-5日 | 最小限のゲーム実行 |
| Phase 2 | 2-3日 | ゲームログ表示 |
| Phase 3 | 3-5日 | 複数戦略の実装 |
| Phase 4 | 2-4日 | 簡易HTMLレポート |

**MVP完了**: 約2週間

### シミュレーション基盤
| フェーズ | 期間（想定） | 主要成果物 |
|---------|------------|----------|
| Phase 5 | 2-3日 | 複数ゲーム実行 |
| Phase 6 | 3-5日 | 基本統計収集 |
| Phase 7 | 3-5日 | 統計の可視化 |
| Phase 8 | 5-7日 | 並列実行 |

**シミュレーション基盤完了**: 約2-3週間

### 拡張機能
| フェーズ | 期間（想定） | 主要成果物 |
|---------|------------|----------|
| Phase 9 | 5-7日 | 詳細統計 |
| Phase 10 | 1-2週間 | 高度な戦略実装 |
| Phase 11 | 3-5日 | パラメータ調整 |
| Phase 12 | 1-2週間 | 高度な可視化 |
| Phase 13 | 2-4週間 | Web UI（オプション） |

**全機能完了**: 約2-3ヶ月（Phase 13を含む場合）

---

## 各フェーズ後の振り返り

各フェーズ完了時に以下を実施：

1. **動作確認**: 成果物が期待通りに動作するか
2. **アーキテクチャレビュー**: 設計の見直しが必要か
3. **次フェーズの計画調整**: 優先度や実装範囲の再検討
4. **ドキュメント更新**: 学んだことを文書化

---

## リスクと対策

| リスク | 影響 | 対策 |
|-------|-----|-----|
| パフォーマンス不足 | 大規模シミュレーションが遅い | 早期にベンチマーク、必要に応じて言語やアルゴリズム変更 |
| 戦略の実装が複雑すぎる | 開発遅延 | Phase 1でインターフェースを検証、段階的に複雑化 |
| データ構造の変更コスト | 後戻りが発生 | Phase 1で拡張性を重視、テストで品質担保 |
| スコープクリープ | 完成しない | 各フェーズのスコープを厳守、追加機能は次フェーズへ |

---

## 次のアクション

1. ✅ プロジェクト仕様の策定（完了）
2. ✅ 開発計画の策定（完了）
3. **⏭️ Phase 1 の詳細設計とタスク分解**
4. Phase 1 の実装開始

---

**作成日**: 2025-11-09
**最終更新**: 2025-11-10
