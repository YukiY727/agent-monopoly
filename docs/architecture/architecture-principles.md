# アーキテクチャ原則

## 基本原則: 全てのアーキテクチャはトレードオフである

> "There are no solutions. There are only trade-offs."
> — Thomas Sowell

完璧なアーキテクチャは存在しません。全ての設計決定は**何かを得る代わりに何かを失う**選択です。アーキテクトの役割は、トレードオフを認識し、プロジェクトのコンテキストと価値観に基づいて最適な判断を下すことです。

---

## プロジェクトの価値観

このプロジェクトでは、以下の優先順位で価値を評価します：

```
保守性 > パフォーマンス > 開発速度
```

### 保守性 (Maintainability)

**最優先事項**: コードは書かれるより読まれる。将来の自分が理解できるコードを。

- **理由**: 研究プラットフォームとして長期的に進化し続ける必要がある
- **具体的な施策**:
  - 型安全性・Null安全性の徹底
  - テスト駆動開発（TDD）
  - 明確な責務分離（レイヤードアーキテクチャ）
  - ドメイン駆動設計の考え方

### パフォーマンス (Performance)

**第2優先**: 必要十分なパフォーマンスを確保。過剰な最適化は避ける。

- **理由**: 10,000ゲーム/分の実行速度が必要だが、マイクロ秒レベルの最適化は不要
- **具体的な施策**:
  - Phase 8でベンチマーク実施
  - 実測に基づく判断
  - ボトルネックが判明してから最適化

### 開発速度 (Development Speed)

**第3優先**: 素早く価値を提供するが、保守性を犠牲にしない。

- **理由**: 曳光弾開発で早期にフィードバックを得る
- **具体的な施策**:
  - YAGNI原則（必要になってから実装）
  - シンプルな設計から始める
  - 段階的な複雑度の追加

---

## トレードオフ分析のフレームワーク

### 1. トレードオフマトリクス

各アーキテクチャ選択肢を以下の観点で評価します：

| 観点 | 評価基準 |
|------|---------|
| **得られるもの (Gains)** | その選択で達成できること、向上する品質特性 |
| **失うもの (Losses)** | その選択で犠牲になること、低下する品質特性 |
| **コスト (Cost)** | 実装・運用・保守のコスト |
| **リスク (Risk)** | 技術的リスク、学習コスト、依存性 |
| **可逆性 (Reversibility)** | 後で変更できるか、変更コストはどの程度か |
| **影響範囲 (Scope)** | システムのどの部分に影響するか |

### 2. 品質特性の評価

ISO 25010の品質モデルに基づいて評価します：

#### 機能性 (Functionality)
- **機能適合性**: 必要な機能を提供しているか
- **正確性**: 正しい結果を提供するか
- **相互運用性**: 他のシステムと連携できるか

#### 信頼性 (Reliability)
- **成熟性**: バグが少ないか
- **可用性**: システムが利用可能な時間の割合
- **障害許容性**: 障害時の挙動
- **回復性**: 障害からの復旧能力

#### 使用性 (Usability)
- **理解性**: 理解しやすいか
- **学習性**: 学習しやすいか
- **運用性**: 操作しやすいか

#### 効率性 (Performance Efficiency)
- **時間効率性**: 実行速度
- **資源効率性**: メモリ・CPU使用量
- **容量**: スケーラビリティ

#### 保守性 (Maintainability)
- **モジュール性**: 独立したコンポーネントに分割されているか
- **再利用性**: コンポーネントを再利用できるか
- **解析性**: 問題の原因を特定しやすいか
- **修正性**: 修正しやすいか
- **試験性**: テストしやすいか

#### 移植性 (Portability)
- **適応性**: 異なる環境に適応できるか
- **設置性**: インストールしやすいか
- **置換性**: 他のシステムと置き換え可能か

---

## 意思決定の原則

### YAGNI (You Aren't Gonna Need It)

**原則**: 必要になってから実装する。推測で複雑化しない。

#### 適用例

**❌ アンチパターン**: Phase 1で将来のマイクロサービス化を見越した複雑な抽象化
```kotlin
// 過剰な抽象化
interface GameEngineService { ... }
class RemoteGameEngineService : GameEngineService { ... }
class LocalGameEngineService : GameEngineService { ... }
```

**✅ 推奨**: Phase 1ではシンプルに実装、必要になってから分割
```kotlin
// シンプルな実装
class GameEngine { ... }
```

#### 判断基準

- **実装する**: 現在のPhaseで確実に必要
- **実装しない**: 将来必要になるかもしれない
- **調査する**: 実装コストが高く、後で変更困難な場合

---

### 実測に基づく判断

**原則**: ベンチマーク、プロファイリング結果で判断する。推測で最適化しない。

#### Phase 8のパフォーマンス評価

```kotlin
// ベンチマーク実装例
@Benchmark
fun benchmarkKotlinCoroutines() {
    val results = runBlocking {
        (1..10_000).map {
            async(Dispatchers.Default) {
                gameEngine.playGame()
            }
        }.awaitAll()
    }
    // 目標: 10,000ゲーム/分
}
```

#### 意思決定プロセス

1. **仮説**: Kotlin Coroutinesで目標達成できるか？
2. **実測**: ベンチマーク実行
3. **評価**: 結果が目標を満たすか？
4. **決定**:
   - 満たす → Kotlin継続
   - 満たさない → Go並列エンジン追加を検討
5. **記録**: ADRとして文書化

---

### 段階的な投資

**原則**: 最小限から始め、必要に応じて拡張する。

#### 技術スタックの進化

```
Phase 1-7:  Kotlin のみ
            ↓
Phase 8:    パフォーマンス実測
            ↓
            目標達成？
            ├─ YES → Kotlin継続
            └─ NO  → Go追加を検討
                     ↓
Phase 10:   Python（強化学習）追加
            ↓
Phase 13:   TypeScript（フロントエンド）追加
```

#### メリット

- **リスク低減**: 複雑度を段階的に追加
- **学習機会**: 各フェーズで学習し、次に活かす
- **後戻りコスト削減**: 小さい段階で問題を発見

---

### 可逆性の確保

**原則**: 後で変更できる設計を優先する。変更困難な決定は慎重に。

#### 可逆性のレベル

| レベル | 説明 | 例 |
|-------|------|-----|
| **高** | 容易に変更可能 | ライブラリの選択、命名規則 |
| **中** | コストをかければ変更可能 | アーキテクチャパターン、DB選択 |
| **低** | 変更が極めて困難 | プログラミング言語、プラットフォーム |

#### 低可逆性の決定の扱い

1. **十分な調査**: 代替案を徹底的に比較
2. **プロトタイプ**: 小規模で実験
3. **段階的導入**: 影響範囲を限定して導入
4. **ADR作成**: 決定理由を詳細に記録

**例: Kotlinの選択**
- **可逆性**: 低（言語変更は極めて困難）
- **対策**:
  - 詳細な比較検討（Go、TypeScript、Pythonとの比較）
  - ADR-0003で決定理由を文書化
  - ドメインロジックとインフラの分離（将来の部分的置換を可能に）

---

## トレードオフの具体例

### 例1: モノリス vs マイクロサービス

#### 評価マトリクス

| 観点 | モノリス | マイクロサービス |
|------|---------|----------------|
| **保守性** | ✅ 高（単一コードベース、リファクタリング容易） | ❌ 低（分散システムの複雑性） |
| **パフォーマンス** | ✅ 高（プロセス内呼び出し） | ❌ 低（ネットワークオーバーヘッド） |
| **開発速度** | ✅ 高（シンプル） | ❌ 低（複雑な設定、デプロイ） |
| **スケーラビリティ** | ❌ 低（全体をスケール） | ✅ 高（サービス単位でスケール） |
| **独立デプロイ** | ❌ 不可（全体を再デプロイ） | ✅ 可能（サービス単位でデプロイ） |
| **技術多様性** | ❌ 単一技術スタック | ✅ サービス毎に最適な技術 |
| **デバッグ容易性** | ✅ 高（単一プロセス） | ❌ 低（分散トレーシング必要） |
| **可用性** | ❌ 低（単一障害点） | ✅ 高（部分的な障害許容） |

#### このプロジェクトでの決定

**✅ 選択**: モノリスアーキテクチャ

**理由**:
1. **プロジェクト規模**: 研究プラットフォームとしては小〜中規模
2. **価値観との一致**: 保守性・開発速度を最優先
3. **チーム規模**: 小規模チーム（1-3人）
4. **デプロイ頻度**: 高頻度デプロイの必要性が低い

**失うもの**:
- サービス単位の独立スケーラビリティ
- 技術スタックの多様性

**判断**: このプロジェクトでは失うものよりも得られるものが大きい

詳細: [ADR-0001: モノリスアーキテクチャの採用](adr/0001-monolith-architecture.md)

---

### 例2: Kotlin vs Go (並列処理)

#### 評価マトリクス

| 観点 | Kotlin (Coroutines) | Go (Goroutine) |
|------|-------------------|----------------|
| **型安全性** | ✅✅ 高（実行時も型安全） | ✅ 高 |
| **Null安全性** | ✅✅ 言語レベル | ✅ 明示的チェック必要 |
| **並列処理** | ✅ Coroutines（やや複雑） | ✅✅ Goroutine（極めてシンプル） |
| **パフォーマンス** | ✅ 高速 | ✅✅ 最速クラス |
| **保守性** | ✅✅ 高（表現力豊か） | ✅ 高（シンプル） |
| **学習コスト** | 🔶 中 | ✅ 低 |
| **エコシステム** | ✅ JVM（成熟） | ✅ 豊富 |
| **デプロイ** | ❌ JVM必要 | ✅✅ 単一バイナリ |

#### このプロジェクトでの決定

**✅ 選択**: まずKotlin、Phase 8で実測後に判断

**段階的アプローチ**:
1. **Phase 1-7**: Kotlinモノリス
   - **得られるもの**: 保守性、型安全性
   - **失うもの**: Goほどシンプルな並列処理ではない

2. **Phase 8**: ベンチマーク実施
   - **目標**: 10,000ゲーム/分
   - **判断**:
     - 達成 → Kotlin継続
     - 未達 → Go並列エンジン追加

3. **Go追加時**（条件付き）:
   - **アーキテクチャ**: Kotlin（コア） + Go（並列エンジン）
   - **通信**: gRPC
   - **得られるもの**: 並列処理のパフォーマンス
   - **失うもの**: シンプルさ（2言語での開発）

**判断理由**:
- YAGNI原則に従い、まずシンプルに
- 実測に基づいて判断
- 可逆性確保（後からGo追加可能）

詳細: [ADR-0003: Kotlinをコア言語として採用](adr/0003-kotlin-as-core-language.md)

---

### 例3: イベントソーシング vs CRUD

#### 評価マトリクス

| 観点 | イベントソーシング | CRUD |
|------|-----------------|------|
| **履歴管理** | ✅✅ 完全な履歴 | ❌ 現在の状態のみ |
| **再現性** | ✅✅ 任意時点の状態再構築 | ❌ 不可 |
| **監査** | ✅✅ 全変更を追跡 | ❌ 限定的 |
| **シンプルさ** | ❌ 複雑 | ✅✅ シンプル |
| **クエリ** | ❌ 複雑（射影が必要） | ✅ シンプル |
| **パフォーマンス（書込）** | ✅ 高速（追記のみ） | ✅ 高速 |
| **パフォーマンス（読込）** | ❌ 低速（再構築必要） | ✅ 高速 |
| **ストレージ** | ❌ 大容量 | ✅ 小容量 |
| **学習コスト** | ❌ 高 | ✅ 低 |

#### このプロジェクトでの決定

**✅ 選択**: イベントログによる簡易的なイベント記録

**Phase 1-12での実装**:
```kotlin
data class GameEvent(
    val timestamp: Long,
    val type: EventType,
    val playerId: String,
    val details: Map<String, Any>
)

class EventLog {
    private val events = mutableListOf<GameEvent>()

    fun record(event: GameEvent) {
        events.add(event)
    }

    fun save(path: String) {
        // JSON/CSV形式で保存
    }
}
```

**得られるもの**:
- 完全な履歴記録（研究プラットフォームとして必須）
- ゲームの完全な再現性
- 後から別の統計分析を追加可能

**失うもの**:
- クエリのシンプルさ
- ストレージコスト

**判断理由**:
- 研究プラットフォームとして完全なデータ記録が必須
- 失うもの（クエリの複雑性）は受け入れ可能
- ストレージコストは現代では大きな問題ではない

**段階的アプローチ**:
- Phase 1-12: シンプルなイベントログ（`List<GameEvent>`）
- Phase 13: リアルタイムイベント配信（WebSocket）
- 将来: 本格的なイベントストア導入を検討（必要になってから）

詳細: [ADR-0002: イベント駆動アーキテクチャの採用](adr/0002-event-driven-architecture.md)

---

## 意思決定プロセス

### ステップ1: コンテキストの明確化

- **何を決定するのか**: 決定事項を明確に定義
- **なぜ今決定するのか**: 決定のタイミングの正当性
- **誰が影響を受けるのか**: ステークホルダーの特定
- **いつまで有効か**: 決定の有効期限

### ステップ2: 選択肢の列挙

- **最低3つ以上**: 選択肢が1つしかない場合は検討不足
- **多様な観点**: 異なるアプローチを検討
- **ステータスクオ**: 「何もしない」も選択肢の1つ

### ステップ3: トレードオフ分析

- **トレードオフマトリクス**: 各選択肢を体系的に評価
- **品質特性**: ISO 25010に基づく評価
- **プロジェクトの価値観**: 保守性 > パフォーマンス > 開発速度

### ステップ4: 実験・検証（必要に応じて）

- **プロトタイプ**: 小規模で実装し、評価
- **ベンチマーク**: パフォーマンスを実測
- **スパイク**: 技術的な実現可能性を検証

### ステップ5: 意思決定

- **明確な判断**: どの選択肢を選ぶか
- **理由の明確化**: なぜその選択をしたのか
- **リスクの認識**: 失うものを理解し、受け入れる

### ステップ6: 記録 (ADR)

- **ADR作成**: Architecture Decision Recordとして文書化
- **トレードオフ明記**: 得られるものと失うものを両方記載
- **レビュー基準**: 将来の見直しのための基準

### ステップ7: 実装

- **段階的導入**: 影響範囲を限定して導入
- **モニタリング**: 決定の妥当性を継続的に監視

### ステップ8: 振り返り

- **各Phase完了時**: 決定が適切だったかを評価
- **状況変化時**: 前提条件が変わったら再評価
- **新しいADR**: 更新・廃止は新しいADRで記録

---

## よくある落とし穴

### ❌ 過剰エンジニアリング

**症状**: 将来の拡張を見越した複雑な抽象化

**原因**: YAGNI原則の無視

**対策**:
- 現在のPhaseで確実に必要なもののみ実装
- 「かもしれない」は実装しない
- リファクタリングで後から拡張

### ❌ 推測による最適化

**症状**: ベンチマークなしでの最適化

**原因**: 実測に基づく判断の欠如

**対策**:
- まず動くものを作る
- プロファイリングでボトルネックを特定
- ボトルネックのみを最適化

### ❌ 技術ドリブン

**症状**: 新しい技術を使うことが目的化

**原因**: プロジェクトの価値観の欠如

**対策**:
- プロジェクトの価値観を常に意識
- 技術はあくまで手段、目的ではない
- トレードオフを明確にする

### ❌ 決定の先送り

**症状**: 重要な決定を避ける

**原因**: 完璧な選択を求めすぎる

**対策**:
- 完璧な選択は存在しないと理解
- 可逆性の高い決定から始める
- 段階的に決定し、学習する

---

## まとめ

アーキテクチャの意思決定は、**トレードオフの認識**と**プロジェクトの価値観に基づく判断**です。

### 重要なポイント

1. **完璧はない**: 全ての選択は何かを犠牲にする
2. **コンテキスト重視**: 同じ技術でも状況により最適解は変わる
3. **実測**: 推測ではなくデータに基づいて判断
4. **YAGNI**: 必要になってから実装
5. **段階的**: 最小限から始め、必要に応じて拡張
6. **可逆性**: 後で変更できる設計を優先
7. **記録**: ADRで決定理由を文書化
8. **振り返り**: 継続的に見直し、改善

### このプロジェクトの価値観

```
保守性 > パフォーマンス > 開発速度
```

この優先順位を常に意識し、トレードオフを評価してください。

---

**参考文献**:
- Martin Fowler, "Software Architecture Guide"
- Gregor Hohpe, "37 Things One Architect Knows About IT Transformation"
- Michael Nygard, "Documenting Architecture Decisions"
- ISO/IEC 25010:2011, "Systems and software Quality Requirements and Evaluation (SQuaRE)"

**作成日**: 2025-11-15
