# アーキテクチャパターン比較

このドキュメントでは、各アーキテクチャパターンを詳細に比較し、プロジェクトに最適な選択を行うための情報を提供します。

---

## 目次

1. [アーキテクチャスタイル](#アーキテクチャスタイル)
   - モノリス vs マイクロサービス
2. [レイヤリングパターン](#レイヤリングパターン)
   - レイヤードアーキテクチャ
   - ヘキサゴナルアーキテクチャ
   - クリーンアーキテクチャ
   - オニオンアーキテクチャ
3. [データアーキテクチャ](#データアーキテクチャ)
   - CRUD
   - イベントソーシング
   - CQRS
4. [並列処理アーキテクチャ](#並列処理アーキテクチャ)
   - スレッドベース
   - コルーチンベース
   - アクターモデル

---

## アーキテクチャスタイル

### モノリス vs マイクロサービス

#### 詳細比較表

| 観点 | モノリス | マイクロサービス |
|------|---------|----------------|
| **アーキテクチャ** | | |
| 構造 | 単一アプリケーション | 独立したサービス群 |
| デプロイ単位 | 全体を一括デプロイ | サービス単位でデプロイ |
| データベース | 単一DB（通常） | サービス毎にDB |
| **開発** | | |
| コードベース | 単一リポジトリ | マルチリポジトリ or モノレポ |
| チーム構成 | 機能別チーム可能 | サービス別チーム |
| 開発速度（初期） | ✅ 高速 | ❌ 低速（初期設定多） |
| 開発速度（後期） | ❌ 低速（コードベース肥大化） | ✅ 高速（独立開発） |
| **運用** | | |
| デプロイ複雑度 | ✅ 低（単一アプリ） | ❌ 高（オーケストレーション必要） |
| モニタリング | ✅ シンプル（単一プロセス） | ❌ 複雑（分散トレーシング） |
| デバッグ | ✅ 容易（単一プロセス） | ❌ 困難（複数サービス跨ぐ） |
| **品質特性** | | |
| パフォーマンス | ✅ 高（プロセス内呼び出し） | ❌ 低（ネットワークオーバーヘッド） |
| スケーラビリティ | ❌ 垂直のみ（全体をスケール） | ✅ 水平・垂直両方（サービス単位） |
| 可用性 | ❌ 単一障害点 | ✅ 部分的障害許容 |
| 保守性 | ✅ 高（単純） → ❌ 低（肥大化） | ❌ 低（分散複雑性） → ✅ 高（独立性） |
| **技術** | | |
| 技術スタック | 単一（統一された技術） | 多様（サービス毎に最適化） |
| 依存管理 | ✅ シンプル | ❌ 複雑（バージョン管理） |
| トランザクション | ✅ ACID（DB） | ❌ 結果整合性 |

#### このプロジェクトでの評価

**プロジェクト特性**:
- 規模: 小〜中規模
- チーム: 1-3人
- デプロイ頻度: 中程度
- スケーラビリティ要求: Phase 8で評価

**選択**: ✅ **モノリスアーキテクチャ**

**理由**:
1. **保守性優先**: 単一コードベースでリファクタリング容易
2. **開発速度**: 小規模チームで高速に開発
3. **デバッグ容易性**: 単一プロセスで問題特定が容易
4. **十分なパフォーマンス**: Phase 8で実測予定

**トレードオフ**:
- **得られるもの**: シンプルさ、開発速度、保守性
- **失うもの**: サービス単位の独立スケーラビリティ
- **判断**: このプロジェクトでは失うものよりも得られるものが大きい

**将来の拡張**:
- Phase 8でパフォーマンス不足なら、並列実行エンジンのみ分離（Go）
- マイクロサービス化は当面不要と判断

詳細: [ADR-0001: モノリスアーキテクチャの採用](adr/0001-monolith-architecture.md)

---

## レイヤリングパターン

### 概要比較

| パターン | 主な特徴 | 依存方向 | 複雑度 |
|---------|---------|---------|-------|
| **レイヤードアーキテクチャ** | 水平レイヤー分割 | 上→下（一方向） | 低 |
| **ヘキサゴナルアーキテクチャ** | ポート&アダプター | 外→内（一方向） | 中 |
| **クリーンアーキテクチャ** | 同心円状レイヤー | 外→内（一方向） | 高 |
| **オニオンアーキテクチャ** | ドメイン中心 | 外→内（一方向） | 中 |

---

### 1. レイヤードアーキテクチャ (Layered Architecture)

#### 構造

```
┌──────────────────────┐
│  Presentation Layer  │  ← UI、CLI
├──────────────────────┤
│   Application Layer  │  ← ユースケース、調整
├──────────────────────┤
│    Domain Layer      │  ← ビジネスロジック
├──────────────────────┤
│ Infrastructure Layer │  ← DB、外部サービス
└──────────────────────┘

依存方向: 上 → 下（一方向）
```

#### このプロジェクトでの実装

```
com.monopoly
├── cli/                 # Presentation Layer
│   └── MonopolyGame.kt
├── application/         # Application Layer (Phase 13以降)
│   └── GameOrchestrator.kt
├── domain/             # Domain Layer
│   ├── model/          # エンティティ、値オブジェクト
│   ├── service/        # ドメインサービス
│   └── strategy/       # 戦略パターン
└── infrastructure/     # Infrastructure Layer (将来)
    └── persistence/
```

#### メリット

- ✅ **シンプル**: 理解しやすい、学習コスト低
- ✅ **標準的**: 多くの開発者に馴染みがある
- ✅ **段階的導入**: 必要に応じてレイヤーを追加
- ✅ **ツールサポート**: IDEやフレームワークの支援

#### デメリット

- ❌ **ドメイン保護が弱い**: Infrastructure Layerへの依存リスク
- ❌ **テスタビリティ**: 下位レイヤーのモック化が必要
- ❌ **肥大化リスク**: レイヤーが肥大化しやすい

#### 適用範囲

**✅ このプロジェクトで採用**

**理由**:
1. **シンプルさ**: Phase 1-7では最もシンプルな構造が適切
2. **段階的導入**: 必要に応じてApplication Layerを追加（Phase 13）
3. **学習コスト**: チームの学習コストが最小

**トレードオフ**:
- **得られるもの**: シンプルさ、開発速度
- **失うもの**: ドメイン保護の強固さ
- **判断**: Phase 1-7ではシンプルさを優先

詳細: [ADR-0004: レイヤードアーキテクチャの採用](adr/0004-layered-architecture.md)

---

### 2. ヘキサゴナルアーキテクチャ (Ports and Adapters)

#### 構造

```
         ┌─────────────────────┐
         │   Driving Adapters  │  ← UI、CLI、REST API
         │  (Primary Adapters) │
         └──────────┬──────────┘
                    │
         ┌──────────▼──────────┐
         │       Ports         │  ← インターフェース
         └──────────┬──────────┘
                    │
         ┌──────────▼──────────┐
         │   Business Logic    │  ← ドメインロジック
         │  (Application Core) │
         └──────────┬──────────┘
                    │
         ┌──────────▼──────────┐
         │       Ports         │  ← インターフェース
         └──────────┬──────────┘
                    │
         ┌──────────▼──────────┐
         │   Driven Adapters   │  ← DB、外部サービス
         │ (Secondary Adapters)│
         └─────────────────────┘

依存方向: Adapters → Core（依存性逆転）
```

#### メリット

- ✅ **テスタビリティ**: アダプターをモック化しやすい
- ✅ **柔軟性**: インフラの変更が容易
- ✅ **ドメイン保護**: ドメインロジックが独立
- ✅ **依存性逆転**: ドメインがインフラに依存しない

#### デメリット

- ❌ **複雑度**: レイヤードより複雑
- ❌ **ボイラープレート**: ポート・アダプター定義が増える
- ❌ **学習コスト**: 概念の理解が必要

#### このプロジェクトでの評価

**❌ Phase 1-7では不採用**

**理由**:
- Phase 1-7ではインフラ層が最小限（ファイルIO程度）
- 複雑度が開発速度を阻害する可能性
- YAGNI原則に従い、必要になってから検討

**将来の検討**:
- Phase 13（Web UI）でAPI層が増えたら再評価
- Phase 10（Python統合）で外部サービス連携が増えたら検討

---

### 3. クリーンアーキテクチャ (Clean Architecture)

#### 構造

```
      ┌─────────────────────────────┐
      │   Frameworks & Drivers      │  ← UI、DB、外部サービス
      │  (Blue Layer - External)    │
      └────────────┬────────────────┘
                   │
      ┌────────────▼────────────────┐
      │  Interface Adapters         │  ← コントローラー、プレゼンター
      │  (Green Layer)              │
      └────────────┬────────────────┘
                   │
      ┌────────────▼────────────────┐
      │  Application Business Rules │  ← ユースケース
      │  (Red Layer)                │
      └────────────┬────────────────┘
                   │
      ┌────────────▼────────────────┐
      │  Enterprise Business Rules  │  ← エンティティ
      │  (Yellow Layer - Core)      │
      └─────────────────────────────┘

依存方向: 外 → 内（同心円の外側から内側へ）
```

#### メリット

- ✅✅ **ドメイン保護**: 最も強固なドメイン保護
- ✅ **テスタビリティ**: 極めて高い
- ✅ **柔軟性**: フレームワーク、DBの変更が容易
- ✅ **長期保守性**: 大規模プロジェクトで有利

#### デメリット

- ❌❌ **複雑度**: 最も複雑
- ❌ **ボイラープレート**: 多数のインターフェース、DTOが必要
- ❌ **学習コスト**: 概念の理解に時間がかかる
- ❌ **開発速度**: 初期開発が遅い

#### このプロジェクトでの評価

**❌ 不採用**

**理由**:
1. **過剰**: このプロジェクトの規模には複雑すぎる
2. **開発速度**: 初期開発速度が大幅に低下
3. **YAGNI**: 将来のフレームワーク変更の可能性は低い

**トレードオフ**:
- **得られるもの**: 最強のドメイン保護、長期保守性
- **失うもの**: 開発速度、シンプルさ
- **判断**: このプロジェクトでは失うものが大きすぎる

---

### 4. オニオンアーキテクチャ (Onion Architecture)

#### 構造

クリーンアーキテクチャに似ているが、よりドメイン中心。

```
      ┌─────────────────────┐
      │  Infrastructure     │  ← DB、UI、外部サービス
      └────────┬────────────┘
               │
      ┌────────▼────────────┐
      │  Application        │  ← ユースケース、サービス
      └────────┬────────────┘
               │
      ┌────────▼────────────┐
      │  Domain Services    │  ← ドメインサービス
      └────────┬────────────┘
               │
      ┌────────▼────────────┐
      │  Domain Model       │  ← エンティティ、値オブジェクト
      └─────────────────────┘

依存方向: 外 → 内（ドメインモデルが中心）
```

#### このプロジェクトでの評価

**❌ 不採用**

**理由**: クリーンアーキテクチャと同様の理由で複雑度が高すぎる

---

### レイヤリングパターンのまとめ

#### このプロジェクトでの選択

**✅ レイヤードアーキテクチャ（シンプル版）**

**選択理由**:
1. **プロジェクト規模**: 小〜中規模には最適
2. **価値観**: 保守性 > パフォーマンス > 開発速度
3. **段階的導入**: Phase 1-7はシンプルに、必要に応じて拡張

**実装方針**:
- Phase 1-7: Domain Layer + CLI Layer（最小限）
- Phase 8-12: 必要に応じてApplication Layerを追加
- Phase 13: Presentation Layer（REST API）を追加

**トレードオフの受け入れ**:
- **失うもの**: 最強のドメイン保護（ヘキサゴナル/クリーン）
- **得られるもの**: シンプルさ、開発速度
- **判断**: このプロジェクトでは適切なバランス

---

## データアーキテクチャ

### CRUD vs イベントソーシング vs CQRS

#### 詳細比較表

| 観点 | CRUD | イベントソーシング | CQRS |
|------|------|-----------------|------|
| **データ** | | | |
| 状態管理 | 現在の状態のみ | 全イベント履歴 | 読込/書込で分離 |
| 履歴 | ❌ なし（ログで対応） | ✅✅ 完全な履歴 | △ 書込側で管理 |
| 再現性 | ❌ 不可 | ✅✅ 任意時点再構築 | △ 書込側で可能 |
| **クエリ** | | | |
| 読込 | ✅ シンプル | ❌ 再構築必要 | ✅✅ 最適化可能 |
| 書込 | ✅ シンプル | ✅ 追記のみ | △ イベント発行 |
| 複雑なクエリ | ✅ 容易 | ❌ 困難 | ✅✅ Read側で最適化 |
| **パフォーマンス** | | | |
| 読込速度 | ✅ 高速 | ❌ 低速（再構築） | ✅✅ 超高速（専用DB） |
| 書込速度 | ✅ 高速 | ✅ 高速（追記のみ） | △ イベント発行 |
| ストレージ | ✅ 小容量 | ❌ 大容量 | ❌ 複数DB |
| **複雑度** | | | |
| 実装 | ✅✅ 最もシンプル | ❌ 複雑 | ❌❌ 最も複雑 |
| 運用 | ✅ シンプル | △ イベントストア管理 | ❌ 複数DB同期 |
| デバッグ | ✅ 容易 | △ イベント追跡 | ❌ 困難（複数DB） |
| **適用領域** | | | |
| 一般的なCRUD | ✅ 最適 | ❌ 過剰 | ❌ 過剰 |
| 監査ログ必須 | ❌ 不向き | ✅✅ 最適 | ✅ 適している |
| 複雑なドメイン | △ 限定的 | ✅ 適している | ✅✅ 最適 |
| 高負荷読込 | △ 限定的 | ❌ 不向き | ✅✅ 最適 |

#### このプロジェクトでの選択

**✅ 簡易イベントログ（イベントソーシングの簡易版）**

**Phase 1-12での実装**:
```kotlin
// シンプルなイベントログ
data class GameEvent(
    val timestamp: Long,
    val type: EventType,
    val playerId: String?,
    val details: Map<String, Any>
)

class EventLog {
    private val events = mutableListOf<GameEvent>()

    fun record(event: GameEvent) {
        events.add(event)
    }

    fun getEvents(): List<GameEvent> = events.toList()

    fun save(path: String) {
        // JSON/CSV形式で保存
    }
}
```

**選択理由**:
1. **研究プラットフォーム**: 完全な履歴が必須
2. **再現性**: ゲームの完全な再生が必要
3. **将来の分析**: 後から新しい統計分析を追加可能

**トレードオフ**:
- **得られるもの**: 完全な履歴、再現性、拡張性
- **失うもの**: クエリのシンプルさ、ストレージコスト
- **判断**: 研究プラットフォームとして得られるものが大きい

**段階的アプローチ**:
- Phase 1-12: シンプルなイベントログ（List<GameEvent>）
- Phase 13: リアルタイムイベント配信（WebSocket）
- 将来: 本格的なイベントストア（Kafka等）を検討（必要になってから）

**CQRS**:
- Phase 1-12では不要（読込要求が低い）
- Phase 13で複雑なダッシュボードが必要になったら検討

詳細: [ADR-0002: イベント駆動アーキテクチャの採用](adr/0002-event-driven-architecture.md)

---

## 並列処理アーキテクチャ

### スレッドベース vs コルーチンベース vs アクターモデル

#### 詳細比較表

| 観点 | スレッドベース | コルーチンベース | アクターモデル |
|------|-------------|---------------|-------------|
| **実装** | | | |
| 言語 | Java、Go等 | Kotlin、Python等 | Erlang、Akka等 |
| 記述量 | ❌ 多い | ✅ 少ない | △ 中程度 |
| 複雑度 | ❌ 高（ロック管理） | ✅ 低（構造化並行性） | △ 中（メッセージパッシング） |
| **パフォーマンス** | | | |
| スレッド数 | ❌ OS制限 | ✅ 軽量（多数可能） | ✅ 軽量 |
| コンテキストスイッチ | ❌ 重い | ✅ 軽い | ✅ 軽い |
| メモリ | ❌ 大（スレッドスタック） | ✅ 小 | ✅ 小 |
| **同期** | | | |
| 共有状態 | ❌ ロック必要 | △ mutex/channel | ✅ なし（メッセージ） |
| デッドロック | ❌ リスク高 | △ リスク中 | ✅ リスク低 |
| データ競合 | ❌ リスク高 | △ リスク中 | ✅ なし |

#### このプロジェクトでの選択

**✅ Kotlin Coroutines（Phase 1-7）**

**実装例**:
```kotlin
suspend fun runParallelSimulations(count: Int): List<GameResult> {
    return coroutineScope {
        (1..count).map { gameId ->
            async(Dispatchers.Default) {
                gameEngine.playGame(gameId)
            }
        }.awaitAll()
    }
}
```

**選択理由**:
1. **言語統合**: Kotlinとの統合が優れている
2. **構造化並行性**: キャンセル、エラーハンドリングが容易
3. **軽量**: 多数のコルーチンを実行可能
4. **段階的導入**: まずコルーチン、不足あればGo検討

**Phase 8での評価**:
```kotlin
@Benchmark
fun benchmarkCoroutines() {
    val start = System.currentTimeMillis()
    val results = runBlocking {
        runParallelSimulations(10_000)
    }
    val duration = System.currentTimeMillis() - start
    val gamesPerMinute = (10_000 / (duration / 1000.0)) * 60

    // 目標: 10,000ゲーム/分
    println("Performance: $gamesPerMinute games/minute")
}
```

**判断基準**:
- **達成**: Kotlin継続
- **未達**: Goでgoroutineベースの並列エンジンを追加検討

詳細: [ADR-0003: Kotlinをコア言語として採用](adr/0003-kotlin-as-core-language.md)

---

## まとめ

### このプロジェクトで採用したアーキテクチャ

| カテゴリ | 採用 | 理由 |
|---------|------|------|
| **スタイル** | モノリス | シンプルさ、開発速度、保守性 |
| **レイヤリング** | レイヤード | シンプル、段階的導入可能 |
| **データ** | 簡易イベントログ | 完全な履歴、研究プラットフォーム要件 |
| **並列処理** | Kotlin Coroutines | 言語統合、段階的評価 |

### トレードオフの受け入れ

全ての選択は**トレードオフ**です。このプロジェクトでは以下を受け入れました：

**失うもの**:
- マイクロサービスの独立スケーラビリティ
- ヘキサゴナル/クリーンアーキテクチャの最強ドメイン保護
- CQRSの読込最適化
- Goのgoroutineほどシンプルな並列処理

**得られるもの**:
- シンプルさ
- 開発速度
- 保守性
- 完全な履歴（研究要件）

**判断**: プロジェクトの価値観（**保守性 > パフォーマンス > 開発速度**）に照らして、得られるものが失うものを上回ると判断しました。

### 将来の見直しポイント

各フェーズで以下を評価し、必要に応じて再検討します：

- **Phase 8**: 並列処理のパフォーマンス評価 → Go追加の要否
- **Phase 10**: Python統合 → インターフェース設計の妥当性
- **Phase 13**: Web UI → API設計、リアルタイム通信の要件

全ての見直しは新しいADRとして記録します。

---

**参考文献**:
- Martin Fowler, "Patterns of Enterprise Application Architecture"
- Eric Evans, "Domain-Driven Design"
- Robert C. Martin, "Clean Architecture"
- Alistair Cockburn, "Hexagonal Architecture"
- Greg Young, "CQRS and Event Sourcing"
- Vaughn Vernon, "Implementing Domain-Driven Design"

**作成日**: 2025-11-15
