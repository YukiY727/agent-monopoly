# ADR-0001: モノリスアーキテクチャの採用

**ステータス**: 承認済み

**日付**: 2025-11-12

**決定者**: プロジェクトアーキテクト

**関連ADR**: なし（初期決定）

---

## コンテキスト (Context)

### 状況

モノポリー研究プラットフォームの開発を開始するにあたり、全体的なアーキテクチャスタイルを決定する必要があります。

- **背景**: 新規プロジェクトの立ち上げ、Phase 1の実装開始前
- **問題**: モノリスとマイクロサービスのどちらを採用すべきか
- **制約**:
  - 小規模チーム（1-3人）
  - 研究プラットフォームとしての長期保守性が必要
  - 早期のフィードバック取得が重要（曳光弾開発）
- **前提**: Phase 1-12は主にシミュレーション機能、Phase 13でWeb UIを追加

### プロジェクトの価値観との関連

```
保守性 > パフォーマンス > 開発速度
```

この決定は特に**保守性**と**開発速度**に大きく影響します。

---

## 決定 (Decision)

**選択**: **モノリスアーキテクチャを採用**

Phase 1-12では単一のKotlinアプリケーションとして実装し、マイクロサービス化は行わない。

---

## 選択肢 (Options Considered)

### 選択肢1: モノリスアーキテクチャ

#### 説明

単一のアプリケーションとしてシステム全体を実装する。全てのコンポーネントが同一プロセスで動作し、単一のデプロイ単位となる。

#### メリット (Pros)

- ✅ **シンプルさ**: 設計・実装・デプロイが単純
- ✅ **開発速度**: 小規模チームで高速に開発可能
- ✅ **デバッグ容易性**: 単一プロセスで問題特定が容易
- ✅ **パフォーマンス**: プロセス内呼び出しでオーバーヘッド最小
- ✅ **リファクタリング**: コードベース全体を容易に変更可能
- ✅ **トランザクション**: ACID特性を活用可能
- ✅ **学習コスト**: チームの学習コストが低い

#### デメリット (Cons)

- ❌ **スケーラビリティ**: 全体を一括でスケールする必要
- ❌ **独立デプロイ不可**: 部分的なデプロイができない
- ❌ **技術スタック**: 単一の技術スタックに限定
- ❌ **肥大化リスク**: 長期的にコードベースが肥大化する可能性

#### 評価

| 観点 | 評価 | 説明 |
|------|------|------|
| 保守性 | ⭐⭐⭐⭐⭐ | 単一コードベース、リファクタリング容易 |
| パフォーマンス | ⭐⭐⭐⭐⭐ | プロセス内呼び出し、オーバーヘッド最小 |
| 開発速度 | ⭐⭐⭐⭐⭐ | シンプルな構成、迅速な開発 |
| スケーラビリティ | ⭐⭐☆☆☆ | 全体スケールのみ |
| テスタビリティ | ⭐⭐⭐⭐☆ | 統合テストが容易 |
| 学習コスト | ⭐⭐⭐⭐⭐ | 低い（標準的なアプローチ） |

---

### 選択肢2: マイクロサービスアーキテクチャ

#### 説明

システムを独立したサービスに分割し、各サービスを個別にデプロイ・スケールする。

想定されるサービス分割：
- ゲームエンジンサービス
- シミュレーション実行サービス
- 統計分析サービス
- レポート生成サービス
- API Gatewayサービス

#### メリット (Pros)

- ✅ **独立スケーラビリティ**: サービス単位でスケール可能
- ✅ **独立デプロイ**: サービス単位でデプロイ可能
- ✅ **技術多様性**: サービス毎に最適な技術選択
- ✅ **障害分離**: 一部サービスの障害が全体に波及しにくい

#### デメリット (Cons)

- ❌ **複雑度**: 分散システムの複雑性（ネットワーク、一貫性、デバッグ）
- ❌ **開発速度**: 初期設定、オーケストレーション、モニタリングの負担
- ❌ **運用コスト**: 複数サービスの管理・監視が必要
- ❌ **パフォーマンス**: ネットワークオーバーヘッド
- ❌ **トランザクション**: 分散トランザクション、結果整合性の複雑さ
- ❌ **リファクタリング**: サービス間の境界変更が困難
- ❌ **学習コスト**: 分散システムの知識が必要

#### 評価

| 観点 | 評価 | 説明 |
|------|------|------|
| 保守性 | ⭐⭐☆☆☆ | 分散システムの複雑性 |
| パフォーマンス | ⭐⭐⭐☆☆ | ネットワークオーバーヘッド |
| 開発速度 | ⭐⭐☆☆☆ | 初期設定・運用の負担 |
| スケーラビリティ | ⭐⭐⭐⭐⭐ | サービス単位で最適化 |
| テスタビリティ | ⭐⭐⭐☆☆ | 統合テストが複雑 |
| 学習コスト | ⭐⭐☆☆☆ | 高い（分散システムの知識） |

---

### 選択肢3: モジュラーモノリス

#### 説明

モノリスだが、内部を明確なモジュールに分割し、将来のマイクロサービス化を容易にする。

#### メリット (Pros)

- ✅ モノリスのシンプルさ
- ✅ 将来のマイクロサービス化が容易

#### デメリット (Cons)

- ❌ 初期の設計コスト
- ❌ YAGNI原則に反する（将来の拡張を見越した設計）

#### 評価

| 観点 | 評価 | 説明 |
|------|------|------|
| 保守性 | ⭐⭐⭐⭐☆ | モジュール境界の管理が必要 |
| パフォーマンス | ⭐⭐⭐⭐⭐ | プロセス内呼び出し |
| 開発速度 | ⭐⭐⭐☆☆ | モジュール設計のコスト |
| スケーラビリティ | ⭐⭐☆☆☆ | 全体スケールのみ |
| テスタビリティ | ⭐⭐⭐⭐☆ | モジュール単位のテスト可能 |
| 学習コスト | ⭐⭐⭐☆☆ | モジュール設計の理解必要 |

---

## トレードオフ分析 (Trade-off Analysis)

### 選択した決定のトレードオフ

#### 得られるもの (Gains)

- ✅ **シンプルさ**: 設計・実装・デプロイ・運用がシンプル
- ✅ **開発速度**: 小規模チームで迅速に開発可能
- ✅ **保守性**: 単一コードベースでリファクタリングが容易
- ✅ **パフォーマンス**: プロセス内呼び出しで高速
- ✅ **デバッグ容易性**: 単一プロセスで問題特定が容易
- ✅ **学習コスト**: 低い学習コスト

#### 失うもの (Losses)

- ❌ **独立スケーラビリティ**: サービス単位のスケールができない
- ❌ **独立デプロイ**: 部分的なデプロイができない
- ❌ **技術多様性**: 単一技術スタックに限定

#### 判断の根拠

**プロジェクトの価値観（保守性 > パフォーマンス > 開発速度）に照らした評価**:

1. **保守性**: モノリスが優位
   - 単一コードベースでリファクタリングが容易
   - 分散システムの複雑性を回避

2. **パフォーマンス**: モノリスが優位
   - プロセス内呼び出しで高速
   - ネットワークオーバーヘッドなし

3. **開発速度**: モノリスが優位
   - 小規模チームで迅速に開発可能
   - インフラ設定が最小限

**失うもの（独立スケーラビリティ）の評価**:
- このプロジェクトの規模では、全体スケールで十分
- Phase 8でパフォーマンス評価を実施し、必要に応じて部分的にサービス分離（Go並列エンジン）を検討

**結論**: 得られるものが失うものを大きく上回る

---

## 根拠 (Rationale)

### なぜこの決定を選択したのか

1. **プロジェクトの価値観との一致**:
   - 保守性・開発速度を最優先するプロジェクトにモノリスが最適
   - マイクロサービスの複雑性は価値観に反する

2. **技術的な優位性**:
   - プロセス内呼び出しで高速
   - 単一プロセスでデバッグが容易
   - ACID特性を活用可能

3. **リスクの評価**:
   - マイクロサービスの複雑性リスク > モノリスのスケーラビリティリスク
   - Phase 8でパフォーマンス実測により、必要に応じて対応可能

4. **コストの考慮**:
   - 開発・運用コストを大幅に削減
   - 小規模チームに最適

5. **可逆性**:
   - 将来マイクロサービス化が必要になった場合、レイヤー分離により部分的に移行可能
   - 段階的な移行が可能（全部か無かではない）

### 実測・検証

Phase 8でのパフォーマンス評価により、モノリスで十分かを検証します：

```
目標: 10,000ゲーム/分
判断:
  達成 → モノリス継続
  未達 → 並列実行エンジンのみ分離（Go）
```

---

## 影響 (Consequences)

### ポジティブな影響

- ✅ **迅速な開発**: Phase 1-7を高速に実装可能
- ✅ **シンプルな運用**: 単一アプリケーションのデプロイ・監視
- ✅ **容易なリファクタリング**: コードベース全体を自由に変更可能
- ✅ **低い学習コスト**: チームの学習コストが最小

### ネガティブな影響

- ❌ **スケーラビリティ制限**: 全体を一括でスケールする必要
  - **緩和策**: Phase 8でベンチマーク実施、必要に応じて部分的にサービス分離

- ❌ **肥大化リスク**: 長期的にコードベースが肥大化する可能性
  - **緩和策**: レイヤー分離、モジュール設計により構造を保つ

### 影響を受ける領域

- **コードベース**: 単一リポジトリ、単一アプリケーション
- **チーム**: シンプルな開発フロー、学習コスト低
- **運用**: 単一デプロイ、シンプルな監視
- **パフォーマンス**: プロセス内呼び出しで高速

---

## 実装計画 (Implementation Plan)

### Phase 1-7: シンプルなモノリス

1. 単一のGradleプロジェクト
2. パッケージ分離（domain、service、cli）
3. レイヤードアーキテクチャで責務分離

### Phase 8: パフォーマンス評価

1. ベンチマーク実施（10,000ゲーム/分目標）
2. 結果に基づいて判断:
   - 達成 → モノリス継続
   - 未達 → 並列実行エンジンのみ分離（Go）

### Phase 13: Web UI追加

1. REST API追加（同一モノリス内）
2. WebSocket追加（リアルタイム通信）
3. フロントエンド（TypeScript）は別リポジトリ

### 段階的なサービス分離（必要に応じて）

マイクロサービス化が必要になった場合の移行パス：

1. **並列実行エンジンのみ分離**（Phase 8で必要な場合）
   - Kotlin（コア） + Go（並列エンジン）
   - gRPC通信

2. **Python強化学習エージェント**（Phase 10）
   - 独立プロセスとして分離
   - JSON/gRPC通信

3. **将来的な完全マイクロサービス化**（必要になってから）
   - サービス境界はレイヤー分離を活用
   - 段階的に移行

---

## 成功基準 (Success Criteria)

この決定が成功したと判断する基準：

- [x] Phase 1-7を予定通り完了（迅速な開発）
- [ ] Phase 8でパフォーマンス目標を達成（10,000ゲーム/分）
- [ ] コードベースの保守性が高い状態を維持（リファクタリング容易性）
- [ ] デバッグ・トラブルシューティングが容易

---

## 見直し基準 (Review Criteria)

以下の場合に、この決定を見直します：

- **Phase 8でパフォーマンス目標未達**: 並列実行エンジン分離を検討
- **コードベースの肥大化**: モジュール分離やサービス分離を検討
- **独立デプロイの必要性**: 複数チームでの開発になった場合
- **スケーラビリティ要求の増大**: サービス単位のスケールが必要になった場合

### 見直しタイミング

- **Phase 8完了時**: パフォーマンス評価結果に基づく判断
- **Phase 13完了時**: Web UI追加後のアーキテクチャ評価
- **各Phase完了時**: 振り返りでアーキテクチャの妥当性を確認

---

## 参考資料 (References)

- Martin Fowler, "Monolith First" (https://martinfowler.com/bliki/MonolithFirst.html)
- Sam Newman, "Building Microservices"
- [パターン比較](../patterns-comparison.md#アーキテクチャスタイル)
- [アーキテクチャ原則](../architecture-principles.md#トレードオフの具体例)

---

## メモ (Notes)

### 議論の経緯

- マイクロサービスも検討したが、プロジェクト規模・チーム規模に対して過剰と判断
- モジュラーモノリスも検討したが、YAGNI原則に従いシンプルなモノリスを選択
- 将来の拡張性は、段階的な移行パスで確保

### 関連する技術選定

- Kotlinをコア言語として選択（ADR-0003）
- レイヤードアーキテクチャを採用（ADR-0004）

---

**作成日**: 2025-11-12
**最終更新**: 2025-11-15
**承認者**: プロジェクトアーキテクト
