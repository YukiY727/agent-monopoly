# モノポリー研究プラットフォーム

## 価値観

### 1. 保守性 > パフォーマンス > 開発速度
コードは書かれるより読まれる。将来の自分が理解できるコードを。

### 2. データ完全性
すべてのゲームイベントを記録。研究の再現性を保証。

### 3. 型安全性
コンパイル時に可能な限りエラーを検出。実行時エラーを最小化。

---

## 開発哲学

### YAGNI（You Aren't Gonna Need It）
必要になってから実装する。推測で複雑化しない。

### 進化的設計
事前設計は最小限。テストを通じて設計を発見し、進化させる。

### 曳光弾開発
各ステップで動作するソフトウェアを保持。早期にフィードバックを得る。

---

## コアプラクティス

### Test-Driven Development
**テストなしでコードを書かない**

1. **Red**: テストを書く
2. **Green**: 最小実装
3. **Refactor**: きれいにする

テストは仕様であり、ドキュメントであり、設計ツール。

### Given-When-Then
各テストに前提条件、操作、期待結果を明示。

### 小さなコミット
1つの変更、1つのコミット。リファクタリングは別コミット。

### ローカルテスト実行

CIで全テストを実行するため、ローカルでは最小限のテストのみ実行：

- コンパイル確認: `./gradlew compileKotlin compileTestKotlin`
- 関連テストのみ: `./gradlew test --tests 'ClassName'`
- 全テストはCI任せ（時間短縮のため）

コミット前はコンパイル確認のみ。CIが失敗したら修正する流れ。

---

## 設計原則

### 単一責任の原則
クラスは1つの理由でのみ変更される。

### 依存性逆転
具象ではなく抽象に依存。テスト可能な設計。

### 依存性注入（DI）

外部から依存を注入し、コンストラクタで受け取る：

- ❌ `class Board() { val spaces = createSpaces() }` （内部で生成）
- ✅ `class Board(spaces: List<Space>)` （外部から注入）

ファクトリメソッドやビルダーは、テストコードや実行時のエントリーポイント（Main.kt等）で使用。
ドメインモデルは依存を受け取るだけに専念。

### 防御的プログラミング
不変性、コピー、型による制約。実行時エラーを防ぐ。

### Null安全性の徹底
**nullableを極力排除し、型で状態を表現する**

- ❌ `val owner: Player? = null`
- ✅ `val ownership: PropertyOwnership = PropertyOwnership.Unowned`

sealed classやデフォルト値で状態を明示的に表現。
nullチェック忘れをコンパイルエラーに。

### 型アノテーションの明示
**可読性向上のため、val変数には常に型を明示する**

- ❌ `val property = gameState.board.getPropertyAt(position)`
- ✅ `val property: Property = gameState.board.getPropertyAt(position)`

型推論に頼らず、意図を明確にする。コードを読む人の認知負荷を減らす。

### デメテルの法則（Law of Demeter）
**オブジェクトは直接の関係を持つオブジェクトとのみ通信する**

最小知識の原則（Principle of Least Knowledge）とも呼ばれる。
メソッドが呼び出して良いのは：

- 自分自身のメソッド
- 引数として渡されたオブジェクトのメソッド
- 自分が生成したオブジェクトのメソッド
- 自分のフィールド（インスタンス変数）のメソッド

メソッドチェーンを避け、カプセル化を守る：

- ❌ `player.getPosition().getSpace().applyEffect(player)`
- ✅ `player.getCurrentSpace().applyEffect(player)` または `gameState.applyCurrentSpaceEffect(player)`

間接的な依存を減らし、結合度を下げることで保守性を向上させる。

### アーキテクチャのトレードオフ原則

**全てのアーキテクチャはトレードオフである**

完璧なアーキテクチャは存在しない。全ての設計決定は何かを得る代わりに何かを失う。
アーキテクトとして重要なのは、トレードオフを認識し、プロジェクトの価値観に基づいて意思決定すること。

#### トレードオフの考え方

1. **得られるもの vs 失うもの**
   - 各選択肢のメリット・デメリットを明示
   - 抽象的な「良い」「悪い」ではなく、具体的な影響を考える

2. **コンテキストの重視**
   - 同じ技術でも、状況により最適解は変わる
   - このプロジェクトの価値観（保守性 > パフォーマンス > 開発速度）に照らして判断

3. **意思決定の記録**
   - なぜその選択をしたのか、何を優先したのかを文書化
   - 将来の自分や他の開発者が判断の背景を理解できるように

#### 意思決定の原則

- **YAGNI優先**: 問題が起きてから解決する。推測で複雑化しない
- **実測に基づく判断**: ベンチマーク、プロファイリング結果で判断する
- **段階的な投資**: 最小限から始め、必要に応じて拡張する
- **可逆性の確保**: 後で変更できる設計を優先する

#### 具体例

**例1: Kotlinモノリス vs マイクロサービス**
- ✅ **選択**: Phase 1-12はKotlinモノリス
- **得られるもの**: シンプルさ、開発速度、デバッグ容易性
- **失うもの**: サービス間の独立したスケーラビリティ
- **判断理由**: このプロジェクト規模ではモノリスで十分。複雑度を避ける

**例2: Kotlin vs Go（並列処理）**
- ✅ **選択**: まずKotlin Coroutinesで実装、Phase 8で実測後に判断
- **得られるもの（Kotlin）**: 型安全性、Null安全性、保守性
- **失うもの（Kotlin）**: Goほど並列処理がシンプルではない
- **判断理由**: 保守性を最優先。パフォーマンス不足が判明してからGo追加を検討

**例3: イベントソーシング vs CRUD**
- ✅ **選択**: イベントログによる簡易的なイベント記録
- **得られるもの**: 完全な履歴、再現性、将来の分析拡張性
- **失うもの**: クエリの複雑化、ストレージコスト
- **判断理由**: 研究プラットフォームとして全データ記録が必須

### オブジェクト指向エクササイズ 9つのルール

コードの質を高めるための制約：

1. **1メソッド1インデント**: メソッドのインデントは1段階まで
2. **else禁止**: early returnやポリモーフィズムで代替
3. **プリミティブラップ**: 全てのプリミティブ型と文字列を型でラップ
4. **1行1ドット**: メソッドチェーンを避け、意図を明確に
5. **省略禁止**: 名前を省略せず、意図を明示
6. **小さなエンティティ**: クラス・メソッドを小さく保つ
7. **2インスタンス変数まで**: 1クラスにつき最大2つ
8. **ファーストクラスコレクション**: コレクションは専用クラスに
9. **getter/setter/プロパティ禁止**: 振る舞いを中心に設計

詳細は [`docs/phases/phase1/coding-guide.md`](docs/phases/phase1/coding-guide.md) 参照。

---

## ドキュメント

### 不変の知識
- 仕様、ルール、開発計画 → `docs/specifications/`, `docs/planning/`

### 変化する知識
- フェーズの詳細、実装状況 → `docs/current-phase.md`, `docs/phases/`

---

## 現在地

現在のフェーズ、技術スタック、タスクは [`docs/current-phase.md`](docs/current-phase.md) を参照

---

**作成日**: 2025-11-12
